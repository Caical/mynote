{"./":{"url":"./","title":"介绍","keywords":"","body":"简介： 本书主要包括高通 SDM660 平台的 Camera 的基础知识、开发流程以及代码分析。 猫猫镇楼 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:24:46 "},"Sdm660_Camera/相机介绍.html":{"url":"Sdm660_Camera/相机介绍.html","title":"第 1 章：SC66_Camera 介绍","keywords":"","body":"SC66_Camera介绍 本书中SC66的工作平台为sdm660，系统为Android10，将会分别从Camera架构、Camera代码组织、以及各层代码分析与工作流程进行介绍。 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 16:54:18 "},"Sdm660_Camera/高通Camera设计.html":{"url":"Sdm660_Camera/高通Camera设计.html","title":"1.1 高通 Camera 设计","keywords":"","body":"高通Camera设计 设计原理： Camera的所有功能被划分为不同的模块，让模块自己来决定自己的事情（高内聚，低耦合）； 模块有统一的接口和格式； 模块中有端口，通过端口把模块连接起来，又把模块挂在总线上； 每一个端口的连接就是一个流，这些流通过pipeline来管理； 每次启动一个camera就创建一个会话，由这个会话来管理此camera的一切事物。对于每一个会话，模块是共享的，它可以是camera的硬件资源也可以是其它资源（如一些软件算法等资源） ； Camera模块结构： 端口，端口分为src、sink、inter，如果这个模块只有source端口，那么它就是一个src模块；如果只有sink端口就是sink模块，如果都有就是中间模块（ISP模块即属于inter模块）。没有端口的模块是不能连接到流中的，但他可以完成一些其他的功能，比如接收引擎的设置，报告事件到bus等。 模块线程，每个模块可以有一个线程来处理模块的事情。一个线程对应一个队列，线程就是从队列中取出数据处理，然后应答回去； 总线回调，当一个模块向总线注册时，总线向其提供一个回调函数，当模块有事件发生时，调用这个函数向bus发消息，然后总线把这个消息提交给管道，管道把这个消息顺着流发下去； 模块的get、set以及process函数，可以参看aecawb_thread_handler()函数awb 和aec 相关的处理。 代码结构：（下列目录未列出完整目录，仅讨论关键文件） 高通camera把sensor端底层设置、ISP效果参数、chomatix等进行了单独的剥离，放在daemon进程中进行。 daemon进程： daemon 进程又名守护进程，因为没有控制终端，所以说他们运行在后台。守护进程一般在系统启动时开始运行，在系统关闭时消亡。进程不因为用户或者其他变化而受到影响。 camera deamon代码放置在vendor/qcom/proprietary/mm-camera目录下，而此目录下的mm-camera2就是最新的camera架构位置。 可以看到media-controller、server-imaging、server-tuning及其它几个目录，重点主要在于media-controller目录。 media-controller |- mct ——包含了camera引擎、pipiline、bus、module、stream及event等定义及封装。 |- modules ——进程需加载的六大模块 |- sensors —— sensor 的驱动模块 —— src模块 |- iface —— ISP interface模块 —— inter模块 |- isp —— 主要是ISP的处理，内部包含众多的模块 —— inter模块 |- stats —— 统计算法模块，如3A，ASD,AFD,IS,GRRO等数据统计的处理 —— sink模块 |- pproc —— post process处理，如flip，rotate等 —— inter模块 |- imglib —— 主要是图片的一些后端处理，如HDR，人脸识别等 —— sink模块 以上各模块内部又包含了众多的模块，具体需要看代码分析。 sensors目录下： sensors ├─configs 不同型号的camera配置文件以及对应的chromatix配置文件 ├─sensor sensor程序 ├─actuator actuator程序 ├─flash flash程序 ├─eeprom eeprom程序 └─chromatix chromatix代码 sensor、actuator、flash、eeprom目录下的lib文件夹里包含不同型号硬件的驱动程序 chromatix下的code根据软件调试的结果导出，在进入目录前，我们会看到 0309 和 0310 这两个目录，其主要是根据平台来决定，具体的定位文件 在/vendor/qcom/proprietary/mm-camera/Android.mk下。 以chromatix_imx230为例（仅截取部分），chromatix中每个目录级对应一个库，最后都会映射到configs下的chromatix配置文件下。 ├─3A │ ├─4k_preview │ ├─hdr_snapshot │ ├─1080p_preview │ ├─hfr_60 │ ├─video_16M ├─cpp │ ├─cpp_hfr_60 │ ├─cpp_video_4k │ ├─cpp_snapshot_hdr │ ├─cpp_video ├─common ├─postproc └─isp ├─snapshot ├─hfr_60 ├─video_4k ├─preview └─hfr_120 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 16:43:44 "},"Sdm660_Camera/代码组织.html":{"url":"Sdm660_Camera/代码组织.html","title":"1.2 代码组织","keywords":"","body":"代码组织 高通平台对于camera的代码组织，大体上还是遵循Android的框架：即上层应用和HAL层交互，高通平台在HAL层里面实现自己的一套管理策略；在kernel中实现sensor的底层驱动。对于最核心的sensor端的底层设置、ISP效果相关等代码则是单独进行了抽离，放在了一个daemon进程中进行管理。 kernel层主要代码 camera在kernel层的主文件为msm.c，负责设备的具体注册及相关方法的填充； 在msm_sensor.c文件中，主要维护高通自己的一个sensor相关结构体—msm_sensor_ctrl_t，同时把dts文件中的配置信息读取出来；kernel层对于不同的sensor对应自己的一个驱动文件— xxsensor.c，主要是把power setting的设定填充到msm_sensor_ctrl_t中。 在vendor目录下，高通把各个sensor实质性的代码放置在此。一部分代码是高通自己实现的daemon进程和kernel层及HAL层进行通讯的框架代码；另一部分则是和sensor相关的chromatix效果代码和sensor lib部分代码(init setting、lens info、output info)。 vendor层主要代码 如上图，高通平台通过一个函数指针数组sub_module_init来管理sensor相关的组件；其中重要的是sensor_sub_module_init和chromatix_sub_module_init模块，对于sensor模块需要对应填充sensor_lib_t下的接口，对于chromatix模块则是通过高通的chromatix工具生成。 从更高的层次来看，sensor部分的代码只是camera子系统的一部分。打开高通vendor下面关于camera的源码也可以看到，/mm-camera2/media-controller/modules目录下面，sensors只是modules文件下面其中的一个子目录。 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 16:37:26 "},"Sdm660_Camera/使用流程.html":{"url":"Sdm660_Camera/使用流程.html","title":"第 2 章：SC66_Camera 使用流程","keywords":"","body":"操作流程： 1. 内核驱动（主要是在设备树上添加传感器各部分的node）： 在设备树上添加对应node； Path：kernel/msm-3.18/Documentation/devicetree/bindings/ 在arch目录下存在不同架构的平台，需要根据目标板平台进行选择（该板为arm64） 需要添加的包括 传感器的GPIO； 相关时钟 ； 电源处理： 并在对应相机的设备树下也进行添加： Path：kernel/msm-3.18/arch/arm64/boot/dts/qcom/yourplatform-camera-sensor-mtp.dtsi 2. 用户空间驱动 在Sensor Driver中参数主要包括： camera ID, slaver address, sensor ID 输出信息格式（bayer/yuv，输出数据的格式） 寄存器信息 sensor的不同输出模式对应不同的寄存器设置，根据这个会有RES0_REG_ARRAY，RES1_REG_ARRAY等，一般对应不同的分辨率输出，对应的需要在res_settings_array，out_info_array等中添加多个res与之对应。主要包括init寄存器数组、启动/停止寄存器数组、解析寄存器数组。 csi的lane数目,必须在sensor最大范围之内，sensor寄存器的设置必须与lane数目相同. 传感器电源开关上电顺序 具体步骤： 添加传感器驱动程序和chromatix代码 添加内核驱动时添加对应电源节点，再按照开关顺序配置电源 配置以下两个.xml文件： vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/configs/yourplatform_camera.xml vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/configs/your_chromatix.xml 添加编译文件 vendor/qcom/proprietary/common/config/device-vendor.mk，在文件中输入要包含在构建中的新库。 添加传感器驱动 在上述sensor/lib里根据传感器型号添加对应传感器驱动，包括（以s5k3p3为例） s5k3p3_lib.c, s5k3p3_lib.h, s5k3p3_pdaf_flip_mirror.h, s5k3p3_pdaf.h, and Android.mk。 一般不需要修改传感器驱动，由相机制造商预先配置好参数。 配置chromatix 在如下路径添加chromatix code Path：vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/chromatix/0310/chromatix_yoursensor 在sensors目录的config文件夹里配置对应chromatix.xml与camera.xml文件。 在chromatix.xml文件里ISP/CPP/3A需要根据上面设置的不同分辨率进行配置。（分辨率设置在s5k3p3_lib.h里)。 camera.xml配置对应相机信息 在sensors目录的configs/Android.mk里修改成对应xml文件。 以上传感器默认为Bayer的，如使用yuv传感器则修改传感器输出信息格式，且无需配置chromatix，其余步骤不变。 3. AF actuator驱动 更新设备树 添加马达用户空间驱动 添加驱动在actuator目录的libs文件夹下 actuator ├─module └─libs ├─bu64244gwz ├─lc898217xc ├─lc898212xd ├─dw9763b 2.添加AF算法调优文件 不需要单独chromatix文件。它包含在传感器3A文件中。 3.更新camera.xml文件 4. EEPRROM与LED_Flash驱动 更新设备树 添加用户空间驱动 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "},"Sdm660_Camera/相机驱动移植流程.html":{"url":"Sdm660_Camera/相机驱动移植流程.html","title":"2.1 Camera_driver 移植流程","keywords":"","body":"Camera 驱动 一、Kernel 代码移植 1. DTS 文件配置 dts 文件目录： 高通SDM660平台代码中，arm64 与 arm走的是同一个目录文件， kernel\\msm-4.4\\arch\\arm64\\boot\\dts\\qcom这个目录其实是 \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom的软链接。 Camera 相关的 dts 文件： kernel\\msm-4.4\\arch\\arm64\\boot\\dts\\qcom\\sdm660.dtsi kernel\\msm-4.4\\arch\\arm64\\boot\\dts\\qcom\\sdm660-camera.dtsi kernel\\msm-4.4\\arch\\arm64\\boot\\dts\\qcom\\sdm660-pinctrl.dtsi kernel\\msm-4.4\\arch\\arm64\\boot\\dts\\qcom\\sdm660-camera-sensor-mtp.dtsi 1.1 sdm660.dtsi 在该文件中，主要功能如下： 引入 sdm660-camera.dtsi 文件 配置 camera_focus 和 camera_snapshot 对应的 GPIO 及 上报的 keycode。 \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660.dtsi // 1. 引入 sdm660-camera.dtsi #include \"sdm660-camera.dtsi\" // 2. 配置 camera_focus 和 camera_snapshot GPIO 及对应的 keycode。 &soc { gpio_keys { status = \"okay\"; compatible = \"gpio-keys\"; input-name = \"gpio-keys\"; pinctrl-names = \"tlmm_gpio_key_active\",\"tlmm_gpio_key_suspend\"; pinctrl-0 = ; pinctrl-1 = ; camera_focus { label = \"camera_focus\"; gpios = ; linux,input-type = ; linux,code = ; debounce-interval = ; }; camera_snapshot { label = \"camera_snapshot\"; gpios = ; linux,input-type = ; linux,code = ; debounce-interval = ; }; }; }; 1.2 sdm660-camera.dtsi 在 sdm660-camera.dtsi 中主要是配置了平台相关的Camera 底层硬件相关的配置，比如 CSI，CS。 如无特殊需求，一般不会修改此处的代码。 部分代码及对应的解释如下： 各参数解析详见： \\kernel\\msm-4.4\\Documentation\\devicetree\\bindings\\media\\video\\msm-csid.txt \\kernel\\msm-4.4\\Documentation\\devicetree\\bindings\\media\\video\\msm-csi-phy.txt &soc { qcom,csiphy@c824000 { // CSI 总线映射的寄存器地址 cell-index = ; // CSI 硬件总线索引号 0 compatible = \"qcom,csiphy-v3.5\", \"qcom,csiphy\"; // compatible = “a厂商，p产品”, “标准bbb类型设备”。 // 那么linux kernel可能首先使用“a厂商，p产品”来匹配适合的driver， // 如果没有匹配到，那么使用字符串“标准bbb类型设备”来继续寻找适合的driver。 reg = ,; // 使用的寄存器地址 及 长度 reg-names = \"csiphy\", \"csiphy_clk_mux\"; // cisphy 寄存器地址为 0xc824000, 长度为 0x1000 // csiphy_clk_mux 寄存器地址为 0xca00120,长度为 0x4 interrupts = ; // interrupt的格式是 interrupt-names = \"csiphy\"; // 中断name，可通过 cat /proc/interrupts 获取 gdscr-supply = ; bimc_smmu-supply = ; qcom,cam-vreg-name = \"gdscr\", \"bimc_smmu\"; // voltage regulators 和 name clocks = , // clocks 和 name , , , , , , , , , , , , , ; clock-names = \"mmssnoc_axi\", \"mnoc_ahb\", \"bmic_smmu_ahb\", \"bmic_smmu_axi\", \"camss_ahb_clk\", \"camss_top_ahb_clk\", \"csi_src_clk\", \"csi_clk\", \"cphy_csid_clk\", \"csiphy_timer_src_clk\", \"csiphy_timer_clk\", \"camss_ispif_ahb_clk\", \"csiphy_clk_src\", \"csiphy_clk\", \"csiphy_ahb2crif\"; qcom,clock-rates = ; // 上面对应所有clock 的速率 status = \"ok\"; }; qcom,csiphy@c825000 { cell-index = ; // CSI 硬件总线索引号 1 compatible = \"qcom,csiphy-v3.5\", \"qcom,csiphy\"; reg = , ; reg-names = \"csiphy\", \"csiphy_clk_mux\"; // cisphy 寄存器地址为 0xc825000, 长度为 0x1000 // csiphy_clk_mux 寄存器地址为 0xca00124 ,长度为 0x4 interrupts = ; interrupt-names = \"csiphy\"; ...... // 此处省略一大段代码，内容和前面 CSI 0 一样，配置clk 及其速率 }; 1.3 sdm660-camera-sensor-mtp.dtsi 文件 sdm660-pinctrl.dtsi和 sdm660-camera-sensor-mtp.dtsi是在 sdm660-mtp.dtsi中被包含的。 \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-mtp.dtsi #include \"sdm660-pinctrl.dtsi\" #include \"sdm660-camera-sensor-mtp.dtsi\" sdm660-camera-sensor-mtp.dtsi是kernel camera 重点要配置的文件 其中包括了 camera 闪光灯的配置，avdd/dovdd/dvdd/vaf 等电压的配置，camera 马达的配置 ，eeprom的配置，camera sensor的配置。 1.3.1 Camera Sensor DTS配置 \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-camera-sensor-mtp.dtsi \\kernel\\msm-4.4\\Documentation\\devicetree\\bindings\\media\\video\\msm-cci.txt &cci { qcom,camera@0 { cell-index = ; // Camera索引号 0，此处注意不要重复了 compatible = \"qcom,camera\"; reg = ; // 和索引号一样 qcom,csiphy-sd-index = ; // 使用 CSI 0，具体根据硬件决定，一般来说， 0：后摄， 1：前摄 qcom,csid-sd-index = ; // 使用 CSI 0 qcom,mount-angle = ; // Sensor 成像方向与主板的角度，camear旋转角度 qcom,led-flash-src = ; // 闪光灯，使用 led_flash0 qcom,actuator-src = ; // 马达，使用 actuator0 qcom,ois-src = ; // 是否支持 光学防抖 qcom,eeprom-src = ; // eeprom 1 cam_vio-supply = ; // IO voltage IO口电压 VDDIO 数字 IO 电源主要给 I2C 部分供电； cam_vana-supply = ; // analog voltage 模拟电压 AVDD 模拟供电，主要给感光区和 ADC 部分供电； cam_vdig-supply = ; // digital voltage 数字电压DVDD 数字供电，主要给 ISP 供电 cam_vaf-supply = ; // AF voltage Camera 自动对焦马达的供电 cam_v_custom1-supply = ; qcom,cam-vreg-name = \"cam_vio\", \"cam_vana\", \"cam_vdig\", \"cam_vaf\",\"cam_v_custom1\"; // 供电配置 及对应的 电压，详见下 qcom,cam-vreg-min-voltage = ; qcom,cam-vreg-max-voltage = ; qcom,cam-vreg-op-mode = ; qcom,gpio-no-mux = ; // 1:表示 gpio mux 不可用 0:表示可用 pinctrl-names = \"cam_default\", \"cam_suspend\"; // Camera gpio clk 和 reset gpio 配置 pinctrl-0 = ; pinctrl-1 = ; gpios = , ; qcom,gpio-reset = ; qcom,gpio-req-tbl-num = ; qcom,gpio-req-tbl-flags = ; qcom,gpio-req-tbl-label = \"CAMIF_MCLK0\", \"CAM_RESET0\"; qcom,sensor-position = ; // 1:前置 0:后置 qcom,sensor-mode = ; ===>{ @ \\kernel\\msm-4.4\\Documentation\\devicetree\\bindings\\media\\video\\msm-cci.txt - qcom,sensor-mode : should contain sensor mode supported - 0 -> back camera 2D - 1 -> front camera 2D - 2 -> back camera 3D - 3 -> back camera int 3D } qcom,cci-master = ; // I2C 0 status = \"ok\"; clocks = , ; clock-names = \"cam_src_clk\", \"cam_clk\"; qcom,clock-rates = ; // clock rate in Hz //- qcom,sensor-type : should contain format of data that sensor streams // - 0 -> bayer format // - 1 -> yuv format }; qcom,camera@1 { cell-index = ; // Camera索引号 1，此处注意不要重复了 compatible = \"qcom,camera\"; reg = ; qcom,csiphy-sd-index = ; qcom,csid-sd-index = ; qcom,mount-angle = ; qcom,actuator-src = ; qcom,eeprom-src = ; cam_vio-supply = ; cam_vana-supply = ; cam_vdig-supply = ; cam_vaf-supply = ; qcom,cam-vreg-name = \"cam_vio\", \"cam_vana\", \"cam_vdig\", \"cam_vaf\"; qcom,cam-vreg-min-voltage = ; qcom,cam-vreg-max-voltage = ; qcom,cam-vreg-op-mode = ; qcom,gpio-no-mux = ; pinctrl-names = \"cam_default\", \"cam_suspend\"; pinctrl-0 = ; pinctrl-1 = ; gpios = , ; qcom,gpio-reset = ; qcom,gpio-req-tbl-num = ; qcom,gpio-req-tbl-flags = ; qcom,gpio-req-tbl-label = \"CAMIF_MCLK\", \"CAM_RESET\"; qcom,sensor-position = ; // 1:前置 0:后置 qcom,sensor-mode = ; // 0 -> back camera 2D qcom,cci-master = ; // I2C 1 status = \"ok\"; clocks = , ; clock-names = \"cam_src_clk\", \"cam_clk\"; qcom,clock-rates = ; }; qcom,camera@2 { cell-index = ; // Camera索引号 2，此处注意不要重复了 compatible = \"qcom,camera\"; reg = ; qcom,csiphy-sd-index = ; qcom,csid-sd-index = ; qcom,mount-angle = ; //qcom,actuator-src = ; // 前报不需要马达，所以此处不用配置马达 ，同样下面也不用配置 af voltage qcom,eeprom-src = ; cam_vio-supply = ; cam_vana-supply = ; cam_vdig-supply = ; qcom,cam-vreg-name = \"cam_vio\", \"cam_vana\", \"cam_vdig\"; qcom,cam-vreg-min-voltage = ; qcom,cam-vreg-max-voltage = ; qcom,cam-vreg-op-mode = ; qcom,gpio-no-mux = ; pinctrl-names = \"cam_default\", \"cam_suspend\"; pinctrl-0 = ; pinctrl-1 = ; gpios = , ; qcom,gpio-reset = ; qcom,gpio-req-tbl-num = ; qcom,gpio-req-tbl-flags = ; qcom,gpio-req-tbl-label = \"CAMIF_MCLK2\", \"CAM_RESET2\"; qcom,sensor-position = ; // 1:前置 0:后置 qcom,sensor-mode = ; // 1 -> front camera 2D qcom,cci-master = ; // I2C 1 status = \"ok\"; clocks = , ; clock-names = \"cam_src_clk\", \"cam_clk\"; qcom,clock-rates = ; }; } 1.3.2 Camera 供电DTS配置（avdd/dovdd/dvdd/vaf） Camera 供电配置要根据具体的硬件来配置， 如果走的是 pm 电源则配置如cam_vio-supply = ; 如果走的是具体GPIO供电，则要做如下配置 ，调用时配置如cam_vana-supply = ; 各GPIO 供电配置如下： \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-camera-sensor-mtp.dtsi &soc { cam_avdd_gpio_regulator: cam_avdd_fixed_regulator { compatible = \"regulator-fixed\"; regulator-name = \"cam_avdd_gpio_regulator\"; regulator-min-microvolt = ; regulator-max-microvolt = ; enable-active-high; gpio = ; // 使用 CPU的 GPIO 51 ，供电 3.6v vin-supply = ; }; cam_dovdd_gpio_regulator: cam_dovdd_fixed_regulator { compatible = \"regulator-fixed\"; regulator-name = \"cam_dovdd_gpio_regulator\"; regulator-min-microvolt = ; regulator-max-microvolt = ; enable-active-high; gpio = ; // 使用 CPU的 GPIO 0 ，供电 3.6v vin-supply = ; }; cam_dvdd_gpio_regulator: cam_dvdd_fixed_regulator { compatible = \"regulator-fixed\"; regulator-name = \"cam_dvdd_gpio_regulator\"; regulator-min-microvolt = ; regulator-max-microvolt = ; enable-active-high; gpio = ; // 使用 PM660L的 gpio 3 ，供电 3.6v vin-supply = ; }; cam_rear_dvdd_gpio_regulator: cam_rear_dvdd_fixed_regulator { compatible = \"regulator-fixed\"; regulator-name = \"cam_rear_dvdd_gpio_regulator\"; regulator-min-microvolt = ; regulator-max-microvolt = ; enable-active-high; gpio = ; // 使用 PM660L的 gpio 4 ，供电 3.6v vin-supply = ; }; cam_vaf_gpio_regulator:cam_vaf_fixed_regulator { compatible = \"regulator-fixed\"; regulator-name = \"cam_vaf_gpio_regulator\"; regulator-min-microvolt = ; regulator-max-microvolt = ; enable-active-high; gpio = ; // 使用 CPU的 gpio 50 ，供电 3.6v vin-supply = ; }; }; 1.3.3 Camera 闪光灯DTS配置 \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-camera-sensor-mtp.dtsi &soc { led_flash0: qcom,camera-flash@0 { cell-index = ; // 闪光灯配置索引 0 compatible = \"qcom,camera-flash\"; // 如下： 如果两颗灯的话，则配置对应的两个供电，如果是一颗灯的主话，则配置一个供电 qcom,flash-source = ;//闪光灯供电配置 qcom,torch-source = ;//手电筒供电配置 qcom,switch-source = ; status = \"ok\"; }; led_flash1: qcom,camera-flash@1 { cell-index = ; // 闪光灯配置索引 1 compatible = \"qcom,camera-flash\"; qcom,flash-source = ; //闪光灯供电配置 qcom,torch-source = ; //手电筒供电配置 qcom,switch-source = ; status = \"ok\"; }; 上述的相关电源配置均在 msm-pm660l.dtsi文件中 \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\msm-pm660l.dtsi flash_led: qcom,leds@d300 { compatible = \"qcom,qpnp-flash-led-v2\"; reg = ; label = \"flash\"; interrupts = , , ; interrupt-names = \"led-fault-irq\", \"all-ramp-down-done-irq\", \"all-ramp-up-done-irq\"; qcom,hdrm-auto-mode; qcom,short-circuit-det; qcom,open-circuit-det; qcom,vph-droop-det; qcom,thermal-derate-en; qcom,thermal-derate-current = ; qcom,isc-delay = ; qcom,pmic-revid = ; pm660l_flash0: qcom,flash_0 { label = \"flash\"; qcom,led-name = \"led:flash_0\"; qcom,max-current = ; // 最大电流 1.5A qcom,default-led-trigger = \"flash0_trigger\"; qcom,id = ; // flash0 qcom,current-ma = ; qcom,duration-ms = ; qcom,ires-ua = ; qcom,hdrm-voltage-mv = ; qcom,hdrm-vol-hi-lo-win-mv = ; }; pm660l_flash1: qcom,flash_1 { label = \"flash\"; qcom,led-name = \"led:flash_1\"; qcom,max-current = ; qcom,default-led-trigger = \"flash1_trigger\"; qcom,id = ; qcom,current-ma = ; qcom,duration-ms = ; qcom,ires-ua = ; qcom,hdrm-voltage-mv = ; qcom,hdrm-vol-hi-lo-win-mv = ; }; pm660l_flash2: qcom,flash_2 { label = \"flash\"; qcom,led-name = \"led:flash_2\"; qcom,max-current = ; qcom,default-led-trigger = \"flash2_trigger\"; qcom,id = ; qcom,current-ma = ; qcom,duration-ms = ; qcom,ires-ua = ; qcom,hdrm-voltage-mv = ; qcom,hdrm-vol-hi-lo-win-mv = ; }; pm660l_torch0: qcom,torch_0 { label = \"torch\"; qcom,led-name = \"led:torch_0\"; qcom,max-current = ; qcom,default-led-trigger = \"torch0_trigger\"; qcom,id = ; qcom,current-ma = ; qcom,ires-ua = ; qcom,hdrm-voltage-mv = ; qcom,hdrm-vol-hi-lo-win-mv = ; }; ...... pm660l_switch0: qcom,led_switch_0 { label = \"switch\"; qcom,led-name = \"led:switch_0\"; qcom,led-mask = ; qcom,default-led-trigger = \"switch0_trigger\"; }; }; 1.3.4 Camera 马达DTS配置 &cci { actuator0: qcom,actuator@0 { cell-index = ; reg = ; compatible = \"qcom,actuator\"; qcom,cci-master = ; // 马达使用的 i2c master , I2C 0 cam_vaf-supply = ; // 马达供电 qcom,cam-vreg-name = \"cam_vaf\"; qcom,cam-vreg-min-voltage = ; qcom,cam-vreg-max-voltage = ; qcom,cam-vreg-op-mode = ; }; actuator1: qcom,actuator@1 { cell-index = ; reg = ; compatible = \"qcom,actuator\"; qcom,cci-master = ; // 马达使用的 i2c master , I2C 1 cam_vaf-supply = ; qcom,cam-vreg-name = \"cam_vaf\"; qcom,cam-vreg-min-voltage = ; qcom,cam-vreg-max-voltage = ; qcom,cam-vreg-op-mode = ; }; 1.3.5 Camera 光学防抖 OSI DTS配置 ois0: qcom,ois@0 { cell-index = ; reg = ; compatible = \"qcom,ois\"; qcom,cci-master = ; // 使用 I2C 0 gpios = ; // GPIO 50 qcom,gpio-vaf = ; qcom,gpio-req-tbl-num = ; qcom,gpio-req-tbl-flags = ; qcom,gpio-req-tbl-label = \"CAM_VAF\"; pinctrl-names = \"cam_default\", \"cam_suspend\"; pinctrl-0 = ; pinctrl-1 = ; status = \"disabled\"; }; 1.3.6 Camera eeprom DTS配置 eeprom0: qcom,eeprom@0 { cell-index = ; reg = ; compatible = \"qcom,eeprom\"; cam_vio-supply = ; cam_vana-supply = ; cam_vdig-supply = ; cam_vaf-supply = ; qcom,cam-vreg-name = \"cam_vio\", \"cam_vana\", \"cam_vdig\", \"cam_vaf\"; qcom,cam-vreg-min-voltage = ; qcom,cam-vreg-max-voltage = ; qcom,cam-vreg-op-mode = ; qcom,gpio-no-mux = ; pinctrl-names = \"cam_default\", \"cam_suspend\"; pinctrl-0 = ; pinctrl-1 = ; gpios = , ; qcom,gpio-reset = ; qcom,gpio-req-tbl-num = ; qcom,gpio-req-tbl-flags = ; qcom,gpio-req-tbl-label = \"CAMIF_MCLK0\", \"CAM_RESET0\"; qcom,sensor-position = ; qcom,sensor-mode = ; qcom,cci-master = ; status = \"ok\"; clocks = , ; clock-names = \"cam_src_clk\", \"cam_clk\"; qcom,clock-rates = ; }; 1.3.7 Camera PM660L GPIO DTS配置 前面我们使用到了两个 PM660L 的GPIO： gpio = ; gpio = ; 不同于 CPU的gpio ，其需要作单独配置，如下： @\\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-camera-sensor-mtp.dtsi &pm660l_gpios { gpio@c300 { /* GPIO4 -CAMERA SENSOR 0 VDIG*/ qcom,mode = ; /* Output */ qcom,pull = ; /* No Pull */ qcom,vin-sel = ; /* VIN1 GPIO_LV */ qcom,src-sel = ; /* GPIO */ qcom,invert = ; /* Invert */ qcom,master-en = ; /* Enable GPIO */ status = \"ok\"; }; gpio@c200 { /* GPIO3 -CAMERA SENSOR 2 VDIG*/ qcom,mode = ; /* Output */ qcom,pull = ; /* No Pull */ qcom,vin-sel = ; /* VIN1 GPIO_LV */ qcom,src-sel = ; /* GPIO */ qcom,invert = ; /* Invert */ qcom,master-en = ; /* Enable GPIO */ status = \"ok\"; }; }; 1.4 sdm660-pinctrl.dtsi 在前面 中，有需要用到的gpio，出于电源管理的需求，需要在 pinctrl 中配置其active 和 suspend 对应的配置： 例如，GPIO 32 和 GPIO 46 以及 GPIO 50 在前边代码中，使用配置如下： gpio 50： pinctrl-names = \"cam_default\", \"cam_suspend\"; pinctrl-0 = ; pinctrl-1 = ; GPIO 32 、GPIO 46： pinctrl-names = \"cam_default\", \"cam_suspend\"; pinctrl-0 = ; pinctrl-1 = ; gpios = , ; \\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-pinctrl.dtsi cam_actuator_vaf_active: cam_actuator_vaf_active { /* ACTUATOR POWER */ mux { pins = \"gpio50\"; function = \"gpio\"; }; config { pins = \"gpio50\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_actuator_vaf_suspend: cam_actuator_vaf_suspend { /* ACTUATOR POWER */ mux { pins = \"gpio50\"; function = \"gpio\"; }; config { pins = \"gpio50\"; bias-pull-down; /* PULL DOWN */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk0_active: cam_sensor_mclk0_active { /* MCLK0 */ mux { /* CLK */ pins = \"gpio32\"; function = \"cam_mclk\"; }; config { pins = \"gpio32\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk0_suspend: cam_sensor_mclk0_suspend { /* MCLK0 */ mux { /* CLK */ pins = \"gpio32\"; function = \"cam_mclk\"; }; config { pins = \"gpio32\"; bias-pull-down; /* PULL DOWN */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_rear_active: cam_sensor_rear_active { /* RESET, STANDBY */ mux { pins = \"gpio46\"; function = \"gpio\"; }; config { pins = \"gpio46\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_rear_suspend: cam_sensor_rear_suspend { /* RESET, STANDBY */ mux { pins = \"gpio46\"; function = \"gpio\"; }; config { pins = \"gpio46\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk1_active: cam_sensor_mclk1_active { /* MCLK1 */ mux { /* CLK */ pins = \"gpio33\"; function = \"cam_mclk\"; }; config { pins = \"gpio33\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk1_suspend: cam_sensor_mclk1_suspend { /* MCLK1 */ mux { /* CLK */ pins = \"gpio33\"; function = \"cam_mclk\"; }; config { pins = \"gpio33\"; bias-pull-down; /* PULL DOWN */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_rear2_active: cam_sensor_rear2_active { /* RESET, STANDBY */ mux { pins = \"gpio48\"; function = \"gpio\"; }; config { pins = \"gpio48\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_rear2_suspend: cam_sensor_rear2_suspend { /* RESET, STANDBY */ mux { pins = \"gpio48\"; function = \"gpio\"; }; config { pins = \"gpio48\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk2_active: cam_sensor_mclk2_active { /* MCLK1 */ mux { /* CLK */ pins = \"gpio34\"; function = \"cam_mclk\"; }; config { pins = \"gpio34\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk2_suspend: cam_sensor_mclk2_suspend { /* MCLK1 */ mux { /* CLK */ pins = \"gpio34\"; function = \"cam_mclk\"; }; config { pins = \"gpio34\"; bias-pull-down; /* PULL DOWN */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_front_active: cam_sensor_front_active { /* RESET VANA*/ mux { pins = \"gpio47\"; function = \"gpio\"; }; config { pins = \"gpio47\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_front_suspend: cam_sensor_front_suspend { /* RESET */ mux { pins = \"gpio47\"; function = \"gpio\"; }; config { pins = \"gpio47\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk3_active: cam_sensor_mclk3_active { /* MCLK3 */ mux { /* CLK */ pins = \"gpio35\"; function = \"cam_mclk\"; }; config { pins = \"gpio35\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_mclk3_suspend: cam_sensor_mclk3_suspend { /* MCLK3 */ mux { /* CLK */ pins = \"gpio35\"; function = \"cam_mclk\"; }; config { pins = \"gpio35\"; bias-pull-down; /* PULL DOWN */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_front_iris_active: cam_sensor_front_iris_active { /* RESET */ mux { pins = \"gpio52\"; function = \"gpio\"; }; config { pins = \"gpio52\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; cam_sensor_front_iris_suspend: cam_sensor_front_iris_suspend { /* RESET */ mux { pins = \"gpio52\"; function = \"gpio\"; }; config { pins = \"gpio52\"; bias-disable; /* No PULL */ drive-strength = ; /* 2 MA */ }; }; 至此，Camera 中 dts 相关的配置好上边这些就ok 了。 2. Kernel Driver 配置 现在比较新的高通代码中，Kernel 中只需要配置好DTS就可以了，驱动代码是以库代码的形式存放在vendor 目录中。 而kernel 中的camera 相关的 C 文件是高通默认的通用文件。 \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2 我们今天重点在移植，这一块的代码，后续我讲camera 工作流程的时候重点来学习。 二、Vendor 代码移植 目前高通中，vendor 中包括了，camera、马达、eeprom、Trunning 效果等库文件，这些是我们要根据需求移植进来的。 接下来我们慢慢写的来。 1. Camera Sensor 库文件代码移植 以 imx350 sensor 为例： @ qcom\\proprietary\\common\\config\\device-vendor.mk @ qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\config\\Android.mk @ qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\config\\imx350_suny.xml @ qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\config\\sdm660_camera.xml @ qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\libs\\imx350\\ @ qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny\\ 1.1 导入Camera Sensor lib 库代码 将 sensor lib库代码放入如下目录： \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\sensor\\libs\\imx350 注意Android.mk中 LOCAL_SRC_FILES:= imx350_lib.c LOCAL_MODULE := libmmcamera_imx350 需要在 \\vendor\\qcom\\proprietary\\common\\config\\device-vendor.mk中导入模块，添加修改如下： MM_CAMERA += libmmcamera_imx350 2. 导入Camera Chromatix 默认效果参数 将默认的 Chromatix 效果参数放入如下目录 \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny 其中包括了，3A 及 ISP 的效果参数，后续Camera Turnning 工程师会代码效果后修以下面的参数。 由于上面每个分别会编译成多个库，所以我们要注意每个库的名字，我们进入每个文件夹的Android.mk 看下： @ mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny\\3A LOCAL_MODULE := libchromatix_imx350_sunny_default_preview_3a LOCAL_MODULE := libchromatix_imx350_sunny_default_video_3a LOCAL_MODULE := libchromatix_imx350_sunny_hfr_120_3a LOCAL_MODULE := libchromatix_imx350_sunny_hfr_60_3a LOCAL_MODULE := libchromatix_imx350_sunny_hfr_90_3a LOCAL_MODULE := libchromatix_imx350_sunny_zsl_preview_3a LOCAL_MODULE := libchromatix_imx350_sunny_zsl_video_3a @ mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny\\common LOCAL_MODULE := libchromatix_imx350_sunny_common @ mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny\\cpp LOCAL_MODULE := libchromatix_imx350_sunny_cpp_hfr_120 LOCAL_MODULE := libchromatix_imx350_sunny_cpp_hfr_60 LOCAL_MODULE := libchromatix_imx350_sunny_cpp_hfr_90 LOCAL_MODULE := libchromatix_imx350_sunny_cpp_liveshot LOCAL_MODULE := libchromatix_imx350_sunny_cpp_preview LOCAL_MODULE := libchromatix_imx350_sunny_cpp_snapshot LOCAL_MODULE := libchromatix_imx350_sunny_cpp_video @ mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny\\isp LOCAL_MODULE := libchromatix_imx350_sunny_hfr_120 LOCAL_MODULE := libchromatix_imx350_sunny_hfr_60 LOCAL_MODULE := libchromatix_imx350_sunny_hfr_90 LOCAL_MODULE := libchromatix_imx350_sunny_liveshot LOCAL_MODULE := libchromatix_imx350_sunny_preview LOCAL_MODULE := libchromatix_imx350_sunny_snapshot LOCAL_MODULE := libchromatix_imx350_sunny_default_video LOCAL_MODULE := libchromatix_imx350_sunny_postproc LOCAL_MODULE := libchromatix_imx350_sunny_oz_preview_3a LOCAL_MODULE := libchromatix_imx350_sunny_oz_video_3a @ mm-camera2\\media-controller\\modules\\sensors\\chromatix\\0310\\chromatix_imx350_sunny\\postproc LOCAL_MODULE := libchromatix_imx350_sunny_postproc 在 \\vendor\\qcom\\proprietary\\common\\config\\device-vendor.mk中添加如下修改： MM_CAMERA += libchromatix_imx350_sunny_default_preview_3a MM_CAMERA += libchromatix_imx350_sunny_default_video_3a MM_CAMERA += libchromatix_imx350_sunny_hfr_120_3a MM_CAMERA += libchromatix_imx350_sunny_hfr_60_3a MM_CAMERA += libchromatix_imx350_sunny_hfr_90_3a MM_CAMERA += libchromatix_imx350_sunny_zsl_preview_3a MM_CAMERA += libchromatix_imx350_sunny_zsl_video_3a MM_CAMERA += libchromatix_imx350_sunny_common MM_CAMERA += libchromatix_imx350_sunny_cpp_hfr_120 MM_CAMERA += libchromatix_imx350_sunny_cpp_hfr_60 MM_CAMERA += libchromatix_imx350_sunny_cpp_hfr_90 MM_CAMERA += libchromatix_imx350_sunny_cpp_liveshot MM_CAMERA += libchromatix_imx350_sunny_cpp_preview MM_CAMERA += libchromatix_imx350_sunny_cpp_snapshot MM_CAMERA += libchromatix_imx350_sunny_cpp_video MM_CAMERA += libchromatix_imx350_sunny_hfr_120 MM_CAMERA += libchromatix_imx350_sunny_hfr_60 MM_CAMERA += libchromatix_imx350_sunny_hfr_90 MM_CAMERA += libchromatix_imx350_sunny_liveshot MM_CAMERA += libchromatix_imx350_sunny_preview MM_CAMERA += libchromatix_imx350_sunny_snapshot MM_CAMERA += libchromatix_imx350_sunny_default_video MM_CAMERA += libchromatix_imx350_sunny_postproc MM_CAMERA += libchromatix_imx350_sunny_oz_preview_3a MM_CAMERA += libchromatix_imx350_sunny_oz_video_3a MM_CAMERA += libchromatix_imx350_sunny_postproc 2.1 chromatix version 0309 和 0310 定义 具体走哪个是由 CHROMATIX_VERSION来控制的，其定义于： \\vendor\\qcom\\proprietary\\mm-camera\\Android.mk ifeq ($(BUILD_SERVER), true) CHROMATIX_VERSION := 0208 else ifeq ($(BUILD_MM_CAMERA2), true) ifeq ($(OEM_CHROMATIX_0308), 1) CHROMATIX_VERSION := 0308E else ifeq ($(call is-board-platform-in-list,sdm660 msm8998),true) CHROMATIX_VERSION := 0310 else CHROMATIX_VERSION := 0309 endif endif ifeq ($(OEM_CHROMATIX_0310), 1) OEM_CHROMATIX:=true endif ifeq ($(OEM_CHROMATIX), true) LOCAL_CHROMATIX_PATH := $(LOCAL_PATH)/../mm-camera-ext/mm-camerasdk/sensor/includes/$(CHROMATIX_VERSION) LOCAL_EXTEN_ISP_INCLUDES := $(LOCAL_PATH)/../mm-camera-ext/mm-camera2/media-controller/modules/isp2/ LOCAL_EXTEN_PPROC_INCLUDES := $(LOCAL_PATH)/../mm-camera-ext/mm-camera2/media-controller/modules/pproc-new/cpp/ LOCAL_EXTEN_CHROMATIX_FILE_PATH := $(LOCAL_PATH)/../mm-camera-ext/mm-camera2/media-controller/modules/sensors/chromatix/$(CHROMATIX_VERSION) else LOCAL_CHROMATIX_PATH := $(LOCAL_PATH)/../mm-camerasdk/sensor/includes/$(CHROMATIX_VERSION) LOCAL_EXTEN_CHROMATIX_FILE_PATH := $(LOCAL_PATH)/mm-camera2/media-controller/modules/sensors/chromatix/$(CHROMATIX_VERSION) endif 3. 修改 Sensor Config XML qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\config\\Android.mk qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\config\\imx350_suny.xml qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\config\\sdm660_camera.xml 3.1 imx350_sunny.xml \\mm-camera2\\media-controller\\modules\\sensors\\configs\\imx350_sunny.xml 在该文件中，主要是描述了对应的 chromatix 模块名字，如下： 可以看出，和前面 chromatix 中的模块名字一模一样。 imx350_sunny_postproc imx350_sunny_common imx350_sunny_snapshot imx350_sunny_snapshot imx350_sunny_default_video imx350_sunny_cpp_preview imx350_sunny_cpp_snapshot imx350_sunny_cpp_video imx350_sunny_cpp_liveshot imx350_sunny_zsl_preview_3a imx350_sunny_zsl_video_3a imx350_sunny_common_oz imx350_sunny_oz_preview imx350_sunny_oz_snapshot imx350_sunny_oz_preview imx350_sunny_cpp_oz_preview imx350_sunny_cpp_oz_snapshot imx350_sunny_cpp_oz_preview imx350_sunny_cpp_liveshot imx350_sunny_oz_preview_3a imx350_sunny_oz_preview_3a imx350_sunny_common_bining imx350_sunny_preview imx350_sunny_snapshot imx350_sunny_default_video imx350_sunny_cpp_preview imx350_sunny_cpp_snapshot imx350_sunny_cpp_video imx350_sunny_cpp_liveshot imx350_sunny_default_preview_3a imx350_sunny_default_video_3a imx350_sunny_common_bining imx350_sunny_preview_bokeh imx350_sunny_preview_bokeh imx350_sunny_default_video imx350_sunny_cpp_preview imx350_sunny_cpp_snapshot imx350_sunny_cpp_video imx350_sunny_cpp_liveshot imx350_sunny_default_preview_3a imx350_sunny_default_video_3a imx350_sunny_common imx350_sunny_hfr_90 imx350_sunny_hfr_90 imx350_sunny_hfr_90 imx350_sunny_cpp_hfr_90 imx350_sunny_cpp_hfr_90 imx350_sunny_cpp_hfr_90 imx350_sunny_cpp_liveshot imx350_sunny_hfr_90_3a imx350_sunny_hfr_90_3a imx350_sunny_common imx350_sunny_hfr_120 imx350_sunny_hfr_120 imx350_sunny_hfr_120 imx350_sunny_cpp_hfr_120 imx350_sunny_cpp_hfr_120 imx350_sunny_cpp_hfr_120 imx350_sunny_cpp_liveshot imx350_sunny_hfr_120_3a imx350_sunny_hfr_120_3a 3.2 sdm660_camera.xml .so ActuatorName : Name of the actuator on this module.The actuator library name should be of the form libactuator_.so. If there is no actuator remove the node. EepromName : Name of the eeprom on this module. Eeprom lib name should be of the form libmmcamera__eeprom.so If there is no eeprom remove the node. FlashName : Name of the flash on this module. The flash library name should be of the form libflash_.so. If there is no flash remove the node. ChromatixName : Name of the tuning xml file. Tuning file contains the list of chromatix library names. If there is no tuning xml file remove the node. Position : Position of the sensor module. Valid values are: BACK, FRONT and BACK_AUX MountAngle : Angle at which the sensor is mounted. Valid values are 0, 90, 180, 270 and 360. To use default mountangle mentioned in kernel use 360. CsiInfo : This node contains information about the receiver configuration. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *CSIDCore : CSID core to receive the data. Valid values are 0, 1, 2 and 3. *LaneMask : Mask to mention which lane is enabled. LaneMask[0] for DL0. LaneMask[1] for CLK. LaneMask[2] for DL1. LaneMask[3] for DL2. LaneMask[4] for DL3 *LaneAssign : Number which describes the lane mapping between sensor and PHY. LaneAssign[0:3] is sensor lane number connected to data lane 0 of PHY on MSM LaneAssign[4:7] is sensor lane number connected to data lane 2 of PHY on MSM LaneAssign[8:11] is sensor lane number connected to data lane 3 of PHY on MSM LaneAssign[12:15] is sensor lane number connected to data lane 4 of PHY on MSM NOTE : Lane 1 is reserved for the clock lane. Wiring and setting it to a data lane is prohibited. ComboMode : Flag to enable combo mode. This flag is enabled if multiple sensors are using same CSI-PHY receiver LensInfo : Information of the lens present in the module. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *FocalLength : FocalLength of the lens in micometers. Distance between the center of curvature to the focal point. *FNumber : FNumber of the lens. *TotalFocusDistance : The total distance in meters the lens could focus. *HorizontalViewAngle : HorizontalViewAngle in degrees *VerticalViewAngle : VerticalViewAngle in degrees *MinFocusDistance : Minimum distance in meters the lens could focus. *VARIABLES MARKED WITH ASTRICK (*) ARE MANDATORY. --> 0 // camera id =0，注意和 dts 中 cell-index 一致 imx362 // sensor name , 这个名字用来找到对应的 sensor lib 库，所以不能错了 ak7374 // lens name ，用来找到对应的马达驱动 sony_imx362 // eeprom name, 用来找到对应的eeprom驱动 imx362_chromatix // chromatix name，用来找到对应的效果文件 pmic // flashlight name, 用来找到 mm-camera2\\media-controller\\modules\\sensors\\flash\\libs 下面对应的库 1 BACK // 后摄 90 // 旋转90度，注意和 dts 中配置的一样 0 // CS 0 0x1F // 4 lane 和 1 clk 同时使能 0x4320 0 // 马达相关的参数，具体看模组 sepc 3.94 1.9 4.64 70.4 55.7 0.1 1 // camera id =1 imx350 dw9800 sony_imx350 imx350_chromatix 1 BACK_AUX // 后二摄 90 1 // CS 1 0x1F 0x4320 0 5.3 2.6 5.0 51.4 40.0 0.3 2 // camera id =2 s5k4h7yx holitech_s5k4h7yx s5k4h7yx_chromatix 1 FRONT // 前摄 270 // 旋转270度 2 // CS2 0x1F 0x4320 0 // 马达相关参数 2.47 2.0 1.9 63.84 47.88 0.1 3.3 sensors_configs_Android.mk \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\configs\\Android.mk 在 Android.mk 中，添加 xml 编译。 ifeq ($(call is-board-platform-in-list, sdm660),true) include $(CLEAR_VARS) LOCAL_MODULE:= camera_config.xml LOCAL_MODULE_CLASS := EXECUTABLES LOCAL_SRC_FILES := sdm660_camera.xml LOCAL_MODULE_TAGS := optional LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/camera LOCAL_MODULE_OWNER := qti include $(BUILD_PREBUILT) include $(CLEAR_VARS) LOCAL_MODULE:= imx350_sunny.xml LOCAL_MODULE_CLASS := EXECUTABLES LOCAL_SRC_FILES := imx350_sunny.xml LOCAL_MODULE_TAGS := optional LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/camera LOCAL_MODULE_OWNER := qti include $(BUILD_PREBUILT) 4. 导入 Camera AF 马达lib库代码 在前面sdm660_camera.xml中，我们可以看出， 使用了 ak7374和dw9800这两种马达。 马达lib库代码位于vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\actuator\\libs中。 从 Android.mk中可以看出，各模块名字为： LOCAL_MODULE := libactuator_dw9800 LOCAL_MODULE := libactuator_ak7374 导入代码后，在 \\vendor\\qcom\\proprietary\\common\\config\\device-vendor.mk中添加如下代码，将模块导入进来： MM_CAMERA += libactuator_dw9800 MM_CAMERA += libactuator_ak7374 5. 导入 Camera Flashlight 闪光灯lib库代码 在前面sdm660_camera.xml中，可以看出flashlight 使用的是默认的 pmic驱动。 代码位置在 \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\flash\\libs\\pmic 在Android.mk中，模块名字为： LOCAL_MODULE := libflash_pmic 导入代码后，在 \\vendor\\qcom\\proprietary\\common\\config\\device-vendor.mk中添加如下代码，将模块导入进来： MM_CAMERA += libflash_pmic 6. 导入 Camera Eeprom OTP lib库代码 在前面sdm660_camera.xml中，可以看出Eeprom使用的是默认的 sony_imx362和sony_imx350驱动。 代码位置在 \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\eeprom\\libs\\sony_imx350 在Android.mk中，模块名字为： LOCAL_MODULE := libmmcamera_sony_imx350_eeprom 导入代码后，在 \\vendor\\qcom\\proprietary\\common\\config\\device-vendor.mk中添加如下代码，将模块导入进来： MM_CAMERA += libmmcamera_sony_imx350_eeprom* 好，至此，camera 代码移植相关的工作就完了，如果这些相关的文件都配置正确的话， 接下来您就可以，编译下载看下是否正常点亮，及抓log 调试下。 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "},"Sdm660_Camera/附加内容.html":{"url":"Sdm660_Camera/附加内容.html","title":"2.2 附加知识","keywords":"","body":"附加知识： 后续学习如果名词存在疑惑，在这边可以查询相应文档。 Note： 什么是平台驱动 《平台设备和平台驱动》 V4L2是什么 《深入理解相机架构V4L2》 高通Camera《Camera V4L2 驱动层分析》 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "},"Sdm660_Camera/kernel层初始化流程.html":{"url":"Sdm660_Camera/kernel层初始化流程.html","title":"第 3 章：kernel 层初始化流程","keywords":"","body":"一、Camera Kernel 驱动 Kernel驱动中高通把Camera系统分为Camera和Sensor两部分： Camera部分是通用的代码逻辑，该部分由msm_cam 设备作为 video设备 与 userspace 进行交互，Qcom自已的MIPI，ISP，CPP 等硬件设备都属于Camera部分。 Sensor 可以理解为外部设备，是不同产商生产的Camera sensor模组。开发者分只需要配置不同的Sensor模组，将其注册到msm_cam设备上，创建好对应的video 设备，其他具体的接口逻辑均由Camera部分来实现。 在实际工作时，camera video设备主要是提供一个v4l2接口，Camera 驱动在接收到event消息后，会把该event消息及其参数以Post event形式发出到hal 层中，hal层接收到camera 驱动post 上来的event，来调用对应的逻辑，如果要操作sensor ，刚调用对应的 video设备就可以了。 二、工作流程 Camera 部分 通过解析compatible = \"qcom,msm-cam\";来初始化并注册好media_device 、v4l2_device、video_device 设备，同时生成/dev/media0节点。 Sensor 部分 通过解析compatible = \"qcom,camera\";来初始化调用probe解析camera sensor的dts节点信息，保存在全局g_sctrl 数组中。 然后，上层在初始化时，依次对每个sensor下发 ioctl 参数，触发其作初始化probe ，上电check_sensor_id 及 创建对应的 /dev/videoX 节点 及 /dev/mediaX 的节点 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 15:00:06 "},"Sdm660_Camera/V4L2分析.html":{"url":"Sdm660_Camera/V4L2分析.html","title":"3.1 V4L2 框架分析","keywords":"","body":"一、V4L2架构 关键结构体： v4l2_device：用来描述一个v4l2设备实例，可以包含多个子设备，对应的是例如 I2C、CSI、MIPI 等设备，它们是从属于一个 V4L2 device 之下的。 v4l2_subdev：用来初始化和控制子设备的方法 video_device：创建设备节点/dev/videoX，用户空间和内核空间沟通的桥梁 videobuf2：视频缓冲的处理 v4l2_fh：文件访问控制 v4l2_ctrl_handler：控制模块，提供子设备（主要是 video 和 ISP 设备）在用户空间的特效操作接口 media_device：用于运行时数据流的管理，嵌入在 V4L2 device 内部 video_device、v4l2_device和v4l2_subdev的关系 二、Camera挂载总线 Linux的设备和驱动通常都要挂在一种总线上，如I2C总线，USB总线等，但在Soc系统中集成的独立外设控制器是不依附于此类总线的，为了统一性，Linux发明了一种虚拟总线——platform总线，相应的设备就是platform_device,驱动就是platform_driver。 Camera也属于一颗集成的Soc，它有很多子设备：sensor感光芯片，eeprom，flash等，通过MIPI传输图像数据，通过I2C控制sensor的行为。因此，Camera 设备属于platform_device,挂在platform总线上。 因此流程上会写一个platform_device，一个platform_driver，然后调用platform_driver_register去初始化。 三、使用流程 注册设备后，platform总线会调用match函数去匹配驱动和设备，一旦匹配成功，就会调用probe函数。 一般\"compatible = \"qcom,msm-cam\"节点匹配设备和驱动。匹配成功了，就会调用msm_probe函数去做实现一些功能。 3.1 msm_probe实现功能 platform只是虚拟的，我们还是要回归现实。现实中，camera是用来拍照，录视频的，所以应该把camera定义为一个v4l2_device实例， 子设备比如sensor，eeprom定义为v4l2_subdev，归v4l2_device统一管理； 但一个 V4L2 device 下属可能有非常多同类型的子设备（两个或者多个 sensor、ISP 等）那么在设备运行的时候怎么知道数据流需要用到哪一个类型的哪一个子设备呢。这个时候需要通过 media_device了，它为子设备建立一条虚拟的连线，建立起来一个运行时的 pipeline（管道），并且可以在运行时动态改变、管理接入的设备。 另外，如果内核空间要和用户空间沟通，我们还应该初始化 video_device msm_probe函数应该完成v4l2_device，media_device,video_device等相关结构体的初始化工作 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "},"Sdm660_Camera/kernel代码分析.html":{"url":"Sdm660_Camera/kernel代码分析.html","title":"3.2 kernel 层代码分析","keywords":"","body":"kernel代码分析 接下来，我们依次来看看 msm_cam、sensor、v4l2 这几部分的代码逻辑： 1. msm-cam 驱动 msm-cam是在dts 中定义的，在\\kernel\\msm-4.4\\arch\\arm\\boot\\dts\\qcom\\sdm660-camera.dtsi中： qcom,msm-cam@ca00000 { compatible = \"qcom,msm-cam\"; reg = ; reg-names = \"msm-cam\"; status = \"ok\"; bus-vectors = \"suspend\", \"svs\", \"nominal\", \"turbo\"; qcom,bus-votes = ; qcom,gpu-limit = ; }; 查找代码，其注册的地方在\\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\msm.c。 可以看出，msm-cam 是以平台驱动的形式注册在kernel 中。 static const struct of_device_id msm_dt_match[] = { {.compatible = \"qcom,msm-cam\"}, {} }; MODULE_DEVICE_TABLE(of, msm_dt_match); static struct platform_driver msm_driver = { .probe = msm_probe, .driver = { .name = \"msm\", .owner = THIS_MODULE, .of_match_table = msm_dt_match, }, }; static int __init msm_init(void) { return platform_driver_register(&msm_driver); } 初始化注册成功后，会调用msm_probe函数，在该函数中，主要工作如下： 初始化 v4l2_device、video_device 、media_device 结构体并分配好KERNEL 内存。 注册 media_device 、v4l2_device、video_device 设备。 创建好 camera debug root fs 关于这部分建议先看一下3.1节的V4L2分析。 \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\msm.c static struct v4l2_device *msm_v4l2_dev; // 初始化一个 v4l2_device 类型的结构体 static int msm_probe(struct platform_device *pdev) { struct msm_video_device *pvdev = NULL; static struct dentry *cam_debugfs_root; // 1. 初始化一个 v4l2_device 类型的结构体，并分配好结构体内存 msm_v4l2_dev = kzalloc(sizeof(*msm_v4l2_dev), GFP_KERNEL); pvdev = kzalloc(sizeof(struct msm_video_device), GFP_KERNEL); // 2. 分配 video_device 结构体内存 pvdev->vdev = video_device_alloc(); // ---> kzalloc(sizeof(struct video_device), GFP_KERNEL); // 3. 分配 media_device 结构体内存 msm_v4l2_dev->mdev = kzalloc(sizeof(struct media_device), GFP_KERNEL); strlcpy(msm_v4l2_dev->mdev->model, MSM_CONFIGURATION_NAME, sizeof(msm_v4l2_dev->mdev->model)); // msm_config msm_v4l2_dev->mdev->dev = &(pdev->dev); // 4. 注册 media_device , 使用的 v4l2 rc = media_device_register(msm_v4l2_dev->mdev); pvdev->vdev->entity.type = MEDIA_ENT_T_DEVNODE_V4L; // V4L pvdev->vdev->entity.group_id = QCAMERA_VNODE_GROUP_ID; // #define QCAMERA_VNODE_GROUP_ID 2 msm_v4l2_dev->notify = msm_sd_notify; // 用于发现对应的 subdev pvdev->vdev->v4l2_dev = msm_v4l2_dev; // 5. 设置父设备为 pdev->dev （也就是 qcom,msm-cam 的设备信息） rc = v4l2_device_register(&(pdev->dev), pvdev->vdev->v4l2_dev); // 6. 注册 video_device设备 strlcpy(pvdev->vdev->name, \"msm-config\", sizeof(pvdev->vdev->name)); pvdev->vdev->release = video_device_release; pvdev->vdev->fops = &msm_fops; // 配置 video_device 的字符设备操作函数 pvdev->vdev->ioctl_ops = &g_msm_ioctl_ops; // 配置 v4l2 IOCTRL pvdev->vdev->minor = -1; pvdev->vdev->vfl_type = VFL_TYPE_GRABBER; rc = video_register_device(pvdev->vdev, VFL_TYPE_GRABBER, -1); // 7. 将当前 msm_video_device 结构体设为私有数据 video_set_drvdata(pvdev->vdev, pvdev); // 8. 分配 msm_queue_head 结构体内存 msm_session_q = kzalloc(sizeof(*msm_session_q), GFP_KERNEL); msm_init_queue(msm_session_q); // 9. 创建 camera 调试目录 cam_debugfs_root = debugfs_create_dir(MSM_CAM_LOGSYNC_FILE_BASEDIR, NULL); rc = cam_ahb_clk_init(pdev); of_property_read_u32(pdev->dev.of_node, \"qcom,gpu-limit\", &gpu_limit); goto probe_end; } 1.1 struct v4l2_device 结构体描述 \\kernel\\msm-4.4\\include\\media\\v4l2-device.h struct v4l2_device { /* dev->driver_data points to this struct. Note: dev might be NULL if there is no parent device as is the case with e.g. ISA devices. */ struct device *dev; #if defined(CONFIG_MEDIA_CONTROLLER) struct media_device *mdev; #endif /* used to keep track of the registered subdevs */ struct list_head subdevs; /* lock this struct; can be used by the driver as well if this struct is embedded into a larger struct. */ spinlock_t lock; /* unique device name, by default the driver name + bus ID */ char name[V4L2_DEVICE_NAME_SIZE]; /* notify callback called by some sub-devices. */ void (*notify)(struct v4l2_subdev *sd, unsigned int notification, void *arg); /* The control handler. May be NULL. */ struct v4l2_ctrl_handler *ctrl_handler; /* Device's priority state */ struct v4l2_prio_state prio; /* Keep track of the references to this struct. */ struct kref ref; /* Release function that is called when the ref count goes to 0. */ void (*release)(struct v4l2_device *v4l2_dev); }; 1.2 struct msm_video_device 结构体描述 \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\msm.h struct msm_video_device { struct video_device *vdev; atomic_t opened; struct mutex video_drvdata_mutex; }; 1.3 struct media_device 结构体描述 struct media_device { /* dev->driver_data points to this struct. */ struct device *dev; // Parent device struct media_devnode devnode; // Media device node char model[32]; // Device model name char serial[40]; // Device serial number (optional) char bus_info[32]; // Unique and stable device location identifier u32 hw_revision; // Hardware device revision u32 driver_version; // Device driver version u32 entity_id; // ID of the next entity to be registered struct list_head entities; // List of registered entities /* Protects the entities list */ spinlock_t lock; // Entities list lock /* Serializes graph operations. */ struct mutex graph_mutex; // Entities graph operation lock int (*link_notify)(struct media_link *link, u32 flags, unsigned int notification); // Link state change notification callback }; 2. Sensor 驱动 还是从 dts 开始看，前面我们配置camera sensor时，节点为 compatible = \"qcom,camera\";对应代码在\\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor_driver.c。 将 qcom,camera注册在平台驱动中，并注册对应的sensor i2c 驱动。 \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor_driver.c static const struct of_device_id msm_sensor_driver_dt_match[] = { {.compatible = \"qcom,camera\"}, {} }; MODULE_DEVICE_TABLE(of, msm_sensor_driver_dt_match); static struct platform_driver msm_sensor_platform_driver = { .probe = msm_sensor_driver_platform_probe, .driver = { .name = \"qcom,camera\", .owner = THIS_MODULE, .of_match_table = msm_sensor_driver_dt_match, }, .remove = msm_sensor_platform_remove, }; static struct i2c_driver msm_sensor_driver_i2c = { .id_table = i2c_id, .probe = msm_sensor_driver_i2c_probe, .remove = msm_sensor_driver_i2c_remove, .driver = { .name = SENSOR_DRIVER_I2C, }, }; static int __init msm_sensor_driver_init(void) { rc = platform_driver_register(&msm_sensor_platform_driver); rc = i2c_add_driver(&msm_sensor_driver_i2c); return rc; } 2.1 平台驱动probe函数 msm_sensor_driver_platform_probe() 在 msm_sensor_driver_platform_probe函数中，其主要工作如下: 创建并分配 msm_sensor_ctrl_t结构体内存。 将sensor device type初始化为 MSM_CAMERA_PLATFORM_DEVICE 解析 节点为 compatible = \"qcom,camera\";的 dts 内容 解析dts 中配置的camera clk 信息 clock-names = \"cam_src_clk\", \"cam_clk\"; qcom,clock-rates = ; \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor_driver.c static int32_t msm_sensor_driver_platform_probe(struct platform_device *pdev) { int32_t rc = 0; struct msm_sensor_ctrl_t *s_ctrl = NULL; // 1. 创建并分配 msm_sensor_ctrl_t 结构体内存。 /* Create sensor control structure */ s_ctrl = kzalloc(sizeof(*s_ctrl), GFP_KERNEL); platform_set_drvdata(pdev, s_ctrl); // 2. 将sensor device type 初始化为 MSM_CAMERA_PLATFORM_DEVICE /* Initialize sensor device type */ s_ctrl->sensor_device_type = MSM_CAMERA_PLATFORM_DEVICE; s_ctrl->of_node = pdev->dev.of_node; /*fill in platform device*/ s_ctrl->pdev = pdev; // 3. 解析 节点为 compatible = \"qcom,camera\"; 的 dts 内容 rc = msm_sensor_driver_parse(s_ctrl); ==========================> | static int32_t msm_sensor_driver_parse(struct msm_sensor_ctrl_t *s_ctrl) | { | /* Allocate memory for sensor_i2c_client */ | s_ctrl->sensor_i2c_client = kzalloc(sizeof(*s_ctrl->sensor_i2c_client), GFP_KERNEL); | | /* Parse dt information and store in sensor control structure */ | rc = msm_sensor_driver_get_dt_data(s_ctrl); // 解析Camera DTS 节点，详见 Chapter 3.2 | | /* Initilize v4l2 subdev info */ | s_ctrl->sensor_v4l2_subdev_info = msm_sensor_driver_subdev_info; | s_ctrl->sensor_v4l2_subdev_info_size = ARRAY_SIZE(msm_sensor_driver_subdev_info); | | /* Initialize default parameters */ | rc = msm_sensor_init_default_params(s_ctrl); // 初始化默认参数 | | // 将 sensor ctrl 节构体保存在 g_sctrl 数组中。 | /* Store sensor control structure in static database */ | g_sctrl[s_ctrl->id] = s_ctrl; | CDBG(\"g_sctrl[%d] %pK\", s_ctrl->id, g_sctrl[s_ctrl->id]); | return rc; | } ; /* Get clocks information */ rc = msm_camera_get_clk_info(s_ctrl->pdev, &s_ctrl->sensordata->power_info.clk_info, &s_ctrl->sensordata->power_info.clk_ptr, &s_ctrl->sensordata->power_info.clk_info_size); ===========================> | // @\\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\common\\cam_soc_api.c | rc = msm_camera_get_clk_info_internal(&pdev->dev, clk_info, clk_ptr, num_clk); id = s_ctrl->id; /* Fill device in power info */ s_ctrl->sensordata->power_info.dev = &pdev->dev; return rc; } 2.2 解析Camera DTS 节点 msm_sensor_driver_get_dt_data() 在该函数中主要是对dts 中配置的camera 节点解析，工作如下: 初始化 msm_camera_sensor_board_info结构体并分配对应的内存 解析 cell-index = ，以此为camera 数组计数 id 检测 camera id 是否大于系统最大支持数量 判断 msm_sensor_ctrl 全局数组中当前id 是否已经初始化 解析Camera 外设信息，包括 \"qcom,actuator-src\"、\"qcom,ois-src\"、\"qcom,eeprom-src\"、\"qcom,led-flash-src\"、\"qcom,csiphy-sd-index\" 解析Camera 电压配置，qcom,cam-vreg-name = \"cam_vio\", \"cam_vana\", \"cam_vdig\", \"cam_vaf\"; 解析Camera GPIO配置解析 \"qcom,gpio-req-tbl-num\"、\"qcom,gpio-req-tbl-flags\"、\"qcom,gpio-req-tbl-label\" 如果配置了使用gpio 供电的话，则在此初化始化，\"qcom,gpio-vana\"、\"qcom,gpio-vio\"、\"qcom,gpio-vaf\"、\"qcom,gpio-vdig\"、\"qcom,gpio-reset\"、\"qcom,gpio-standby\"、\"qcom,gpio-flash-en\" 解析I2C master ，\"qcom,cci-master = ;\" 解析摄像头旋转角度\"qcom,mount-angle\"，如果没有配置默认设置为0 解析sensor 前后摄\"qcom,sensor-position\" 解析\"qcom,sensor-mode\" \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor_driver.c static int32_t msm_sensor_driver_get_dt_data(struct msm_sensor_ctrl_t *s_ctrl) { int32_t rc = 0, i = 0; struct msm_camera_sensor_board_info *sensordata = NULL; struct device_node *of_node = s_ctrl->of_node; uint32_t cell_id; // 1. 初始化 msm_camera_sensor_board_info 结构体并分配对应的内存 s_ctrl->sensordata = kzalloc(sizeof(*sensordata), GFP_KERNEL); sensordata = s_ctrl->sensordata; // 2. 解析 cell-index = ，以此为camera 数组计数 id /** Read cell index - this cell index will be the camera slot where this camera will be mounted */ rc = of_property_read_u32(of_node, \"cell-index\", &cell_id); s_ctrl->id = cell_id; // 3. 检测camera id是否大于系统最大支持数量 if (cell_id >= MAX_CAMERAS) { pr_err(\"failed: invalid cell_id %d\", cell_id); rc = -EINVAL; goto FREE_SENSOR_DATA; } // 4. 判断全msm_sensor_ctrl 全局数组中当前id 是否已经初始化 /* Check whether g_sctrl is already filled for this cell_id */ if (g_sctrl[cell_id]) { pr_err(\"failed: sctrl already filled for cell_id %d\", cell_id); rc = -EINVAL; goto FREE_SENSOR_DATA; } // 5. 解析Camera 外设信息，包括 \"qcom,actuator-src\"、\"qcom,ois-src\"、\"qcom,eeprom-src\"、 // \"qcom,led-flash-src\"、\"qcom,csiphy-sd-index\" /* Read subdev info */ rc = msm_sensor_get_sub_module_index(of_node, &sensordata->sensor_info); ==================> + //@\\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\io\\msm_camera_dt_util.c + int msm_sensor_get_sub_module_index(struct device_node *of_node, struct msm_sensor_info_t **s_info) + { + struct msm_sensor_info_t *sensor_info; + sensor_info = kzalloc(sizeof(*sensor_info), GFP_KERNEL); + + for (i = 0; i subdev_id[i] = -1; /* Subdev expose additional interface for same sub module*/ + sensor_info->subdev_intf[i] = -1; + } + src_node = of_parse_phandle(of_node, \"qcom,actuator-src\", 0); + sensor_info->subdev_id[SUB_MODULE_ACTUATOR] = val; + + src_node = of_parse_phandle(of_node, \"qcom,ois-src\", 0); + sensor_info->subdev_id[SUB_MODULE_OIS] = val; + + src_node = of_parse_phandle(of_node, \"qcom,eeprom-src\", 0); + sensor_info->subdev_id[SUB_MODULE_EEPROM] = val; + + src_node = of_parse_phandle(of_node, \"qcom,led-flash-src\", 0); + sensor_info->subdev_id[SUB_MODULE_LED_FLASH] = val; + + if (of_get_property(of_node, \"qcom,csiphy-sd-index\", &count)) { + count /= sizeof(uint32_t); + val_array = kzalloc(sizeof(uint32_t) * count, GFP_KERNEL); + rc = of_property_read_u32_array(of_node, \"qcom,csiphy-sd-index\", val_array, count); + for (i = 0; i subdev_id[SUB_MODULE_CSIPHY + i] = val_array[i]; + CDBG(\"%s csiphy_core[%d] = %d\\n\", __func__, i, val_array[i]); + } + //.... 省略一部分解析代码 power_info.cam_vreg, &sensordata->power_info.num_vreg); ==================> + //@\\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\io\\msm_camera_dt_util.c + int msm_camera_get_dt_vreg_data(struct device_node *of_node, struct camera_vreg_t **cam_vreg, int *num_vreg) + { + count = of_property_count_strings(of_node, \"qcom,cam-vreg-name\"); + CDBG(\"%s qcom,cam-vreg-name count %d\\n\", __func__, count); + vreg = kzalloc(sizeof(*vreg) * count, GFP_KERNEL); + *cam_vreg = vreg; + *num_vreg = count; + for (i = 0; i power_info.gpio_conf), of_node); ==================> + //@\\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\io\\msm_camera_dt_util.c + int32_t msm_sensor_driver_get_gpio_data(struct msm_camera_gpio_conf **gpio_conf, struct device_node *of_node) + { + uint16_t *gpio_array = NULL; + struct msm_camera_gpio_conf *gconf = NULL; + gpio_array_size = of_gpio_count(of_node); + gconf = kzalloc(sizeof(struct msm_camera_gpio_conf), + *gpio_conf = gconf; + + // 解析 \"qcom,gpio-req-tbl-num\"、\"qcom,gpio-req-tbl-flags\"、\"qcom,gpio-req-tbl-label\" + rc = msm_camera_get_dt_gpio_req_tbl(of_node, gconf, gpio_array, gpio_array_size); + ============> + + of_get_property(of_node, \"qcom,gpio-req-tbl-num\", &count) + + rc = of_property_read_u32_array(of_node, \"qcom,gpio-req-tbl-num\", val_array, count); + + rc = of_property_read_u32_array(of_node, \"qcom,gpio-req-tbl-flags\", val_array, count); + + for (i = 0; i cam_gpio_req_tbl[i].label); + + CDBG(\"%s cam_gpio_req_tbl[%d].label = %s\\n\", __func__, i,gconf->cam_gpio_req_tbl[i].label); + + } + + rc = of_property_read_u32(of_node, \"qcom,gpio-vana\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VANA] = gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-vio\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VIO] = gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-vaf\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VAF] = gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-vdig\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_VDIG] = gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-reset\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_RESET] = gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-standby\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_STANDBY] =gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-af-pwdm\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_AF_PWDM] = gpio_array[val]; + rc = of_property_read_u32(of_node, \"qcom,gpio-flash-en\", &val); + gconf->gpio_num_info->gpio_num[SENSOR_GPIO_FL_EN] = gpio_array[val]; + //.... 省略一部分解析代码 + ;\" /* Get CCI master */ rc = of_property_read_u32(of_node, \"qcom,cci-master\", &s_ctrl->cci_i2c_master); CDBG(\"qcom,cci-master %d, rc %d\", s_ctrl->cci_i2c_master, rc); // 9. 解析摄像头旋转角度\"qcom,mount-angle\"，如果没有配置默认设置为0 /* Get mount angle */ if (0 > of_property_read_u32(of_node, \"qcom,mount-angle\", &sensordata->sensor_info->sensor_mount_angle)) { /* Invalidate mount angle flag */ sensordata->sensor_info->is_mount_angle_valid = 0; sensordata->sensor_info->sensor_mount_angle = 0; } else { sensordata->sensor_info->is_mount_angle_valid = 1; } CDBG(\"%s qcom,mount-angle %d\\n\", __func__,sensordata->sensor_info->sensor_mount_angle); // 10. 解析sensor 前后摄\"qcom,sensor-position\" if (0 > of_property_read_u32(of_node, \"qcom,sensor-position\",&sensordata->sensor_info->position)) { CDBG(\"%s:%d Invalid sensor position\\n\", __func__, __LINE__); sensordata->sensor_info->position = INVALID_CAMERA_B; } // 11. 解析sensor-mode if (0 > of_property_read_u32(of_node, \"qcom,sensor-mode\", &sensordata->sensor_info->modes_supported)) { CDBG(\"%s:%d Invalid sensor mode supported\\n\", __func__, __LINE__); sensordata->sensor_info->modes_supported = CAMERA_MODE_INVALID; } /* Get vdd-cx regulator */ /*Optional property, don't return error if absent */ of_property_read_string(of_node, \"qcom,vdd-cx-name\",&sensordata->misc_regulator); CDBG(\"qcom,misc_regulator %s\", sensordata->misc_regulator); s_ctrl->set_mclk_23880000 = of_property_read_bool(of_node,\"qcom,mclk-23880000\"); CDBG(\"%s qcom,mclk-23880000 = %d\\n\", __func__,s_ctrl->set_mclk_23880000); return rc; } 2.2.1 msm_camera_sensor_board_info 结构体描述 在msm_camera_sensor_board_info 中保存了所有camera 及硬件相关的name及参数。 \\kernel\\msm-4.4\\include\\soc\\qcom\\camera2.h struct msm_camera_sensor_board_info { const char *sensor_name; // camera sensor name const char *eeprom_name; // eeprom name const char *actuator_name; // actuator name const char *ois_name; // ois name const char *flash_name; // flashlight name const char *special_support_sensors[MAX_SPECIAL_SUPPORT_SIZE]; int32_t special_support_size; struct msm_camera_slave_info *slave_info; // i2c addr struct msm_camera_csi_lane_params *csi_lane_params; struct msm_camera_sensor_strobe_flash_data *strobe_flash_data; struct msm_actuator_info *actuator_info; struct msm_sensor_info_t *sensor_info; const char *misc_regulator; struct msm_camera_power_ctrl_t power_info; struct msm_camera_sensor_slave_info *cam_slave_info; }; 2.2.2 Camera 支持的外设类型 sensor_sub_module_t \\kernel\\msm-4.4\\include\\uapi\\media\\msm_cam_sensor.h enum sensor_sub_module_t { SUB_MODULE_SENSOR, SUB_MODULE_CHROMATIX, SUB_MODULE_ACTUATOR, SUB_MODULE_EEPROM, SUB_MODULE_LED_FLASH, SUB_MODULE_STROBE_FLASH, SUB_MODULE_CSID, SUB_MODULE_CSID_3D, SUB_MODULE_CSIPHY, SUB_MODULE_CSIPHY_3D, SUB_MODULE_OIS, SUB_MODULE_EXT, SUB_MODULE_IR_LED, SUB_MODULE_IR_CUT, SUB_MODULE_MAX, }; 2.3 【重点】全局CameraSensorCtrol数组g_sctrl g_sctrl 是静态全局的一个msm_sensor_ctrl_t * 结构体指针数组，其定义如下： /* Static declaration */ static struct msm_sensor_ctrl_t *g_sctrl[MAX_CAMERAS]; 前面我们在配置dts 时也发现了，通常我们要配置的camera数量是大于1的，前面代码中，我们配置了3个Camera，两个后摄，一个前摄。而这三个camera dts 中的节点都是一样的\"qcom,camera\"。 可以看出，驱动和设备会匹配三次，换句话说，也就是 msm_sensor_driver_platform_probe()函数会走三次，每次传递的dts节点内容是不一样的，三个camera都会依次probe 一次， 从而，当probe 完毕后，会保存三个struct msm_sensor_ctrl_t *结构体的数据保存在全局 g_sctrl 中。 至此，我们代码中，就把dts 的内容成功的转化为了msm_sensor_ctrl_t结构体保存在 全局 g_sctrl 中。 2.4 【重点】摄像头probe 函数 msm_sensor_driver_probe() 3.1 中我们分析过了 平台驱动probe函数 msm_sensor_driver_platform_probe()，这个函数主要作用还是解析DTS，但并不会真正probe camera sensor。那，camera sensor probe 是在什么时候呢？ 其实，camera probe 并不是和其他kernerl 驱动一样，在初始化时就probe，而是通过hal 层下发 probe 指令来控制probe 的。 2.4.1 hal层函数 module_sensor_init() hal层代码位于 \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\module\\module_sensor.c \\vendor\\qcom\\proprietary\\mm-camera\\mm-camera2\\media-controller\\modules\\sensors\\module\\module_sensor.c mct_module_t *module_sensor_init(const char *name) { ...... /* module_sensor_probe_sensors */ ret = sensor_init_probe(module_ctrl); /* find all the actuator, etc with sensor */ ret = module_sensor_find_other_subdev(module_ctrl); /* Init sensor modules */ ret = mct_list_traverse(module_ctrl->sensor_bundle, module_sensors_subinit,NULL); /* intiialize the eeprom */ ret = mct_list_traverse(module_ctrl->sensor_bundle, module_sensor_init_eeprom,module_ctrl->eebin_hdl); /* Create chromatix manager */ ret = mct_list_traverse(module_ctrl->sensor_bundle, module_sensor_init_chromatix, module_ctrl->eebin_hdl); /* Initialize dual cam stream mutex */ pthread_mutex_init(&module_ctrl->dual_cam_mutex, NULL); } 2.4.2 hal层函数 sensor_init_probe() 上层代码逻辑我们后续会详细分析，并不是我们本章的重点，我们重点关注sensor_init_probe()，其内容如下: 在 sensor_init_eebin_probe()中，我们可以看出，知道camera 数量后，在for循环中，依次调用 sensor_probe()函数初始化每个camera，我们当前代码中有三个camera，这面就会调用三次sensor_probe()。 至于 hal 层中又是如何知道我们是三个camera的，后续我们分析到hal 层再说吧。 /** sensor_init_probe: probe available sensors * * @module_ctrl: sensor ctrl pointer * * Return: 0 for success and negative error on failure * * 1) Find sensor_init subdev and it * 2) Open EEPROM subdev and check whether any sensor library * is present in EEPROM * 3) Open sensor libraries present in dumped firware location * 4) Check library version of EEPROM and dumped firmware * 5) Load latest of both * 6) Pass slave information, power up and probe sensors * 7) If probe succeeds, create video node and sensor subdev * 8) Repeat step 2-8 for all sensor libraries present in * EEPROM * 9) Repeat step 6-8 for all sensor libraries present in * absolute path **/ boolean sensor_init_probe(module_sensor_ctrl_t *module_ctrl) { ...... ret = sensor_init_eebin_probe(module_ctrl, sd_fd); ...... RETURN_ON_FALSE(sensor_init_xml_probe(module_ctrl, sd_fd)); } static boolean sensor_init_eebin_probe(module_sensor_ctrl_t *module_ctrl,int32_t sd_fd) { SLOW(\"Enter\"); bin_ctl.cmd = EEPROM_BIN_GET_NUM_DEV; bin_ctl.ctl.q_num.type = EEPROM_BIN_LIB_SENSOR; bin_ctl.ctl.q_num.num_devs = 0; eebin_interface_control(module_ctrl->eebin_hdl, &bin_ctl); num_devs = bin_ctl.ctl.q_num.num_devs; SLOW(\"num_devs:%d\", num_devs); for (i = 0; i eebin_hdl, &bin_ctl); if (rc 虽然前面也有 sensor_probe,但正常流程中，我们走的不是eebin,而是通过 sensor_init_xml_probe(module_ctrl, sd_fd) 来解析 vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/configs/sdm660_camera.xml 文件， 通过 xml 中 配置的sensor name 和 subdev name，来下发参数。 详细如下： 首先拼凑 sdm660_camera.xml 的字符串路径 odm 公司如果要自已定制路径的话，也可以通过 属性 persist.vendor.camera.customer.config 来配置 开始解析 sdm660_camera.xml文件中的 CameraConfigurationRoot 节点 通过 CameraModuleConfig 的数量可以知道 ，当前支持多少个camera 解析每个camera 的信息，并且在 sensor_probe[]数组中检查当前sensor 是否已经probe 过了 根据xml 中解析的结果，调用 sensor_probe 开始正式probe 当所有xml 中的项都遍历完成后，关闭xml static boolean sensor_init_xml_probe(module_sensor_ctrl_t *module_ctrl, int32_t sd_fd) { // 首先拼凑 sdm660_camera.xml 的字符串路径 /* Create the xml path from data partition */ snprintf(config_xml_name, BUFF_SIZE_255, \"%s%s\", CONFIG_XML_PATH, CONFIG_XML); // odm 公司如果要自已定制路径的话，也可以通过 属性 persist.vendor.camera.customer.config 来配置 if (access(config_xml_name, R_OK)) { SHIGH(\" read fail (non-fatal) %s. Trying from system partition\",config_xml_name); if (csidtg_enable) { /* Create the CSIDTG xml path from system partition */ snprintf(config_xml_name, BUFF_SIZE_255, \"%s%s\", CONFIG_XML_SYSTEM_PATH, CSIDTG_CONFIG_XML); } else { property_get(\"persist.vendor.camera.customer.config\", custom_xml_name, CONFIG_XML); /* Create the xml path from system partition */ snprintf(config_xml_name, BUFF_SIZE_255, \"%s%s\", CONFIG_XML_SYSTEM_PATH, custom_xml_name); } } SHIGH(\"reading from file %s\", config_xml_name); // 开始解析 sdm660_camera.xml文件中的 CameraConfigurationRoot 节点 /* Get the Root pointer and Document pointer of XMl file */ ret = sensor_xml_util_load_file(config_xml_name, &docPtr, &rootPtr, \"CameraConfigurationRoot\"); // 通过 CameraModuleConfig 的数量可以知道 ，当前支持多少个camera /* Get number of camera module configurations */ num_cam_config = sensor_xml_util_get_num_nodes(rootPtr, \"CameraModuleConfig\"); SLOW(\"num_cam_config = %d\", num_cam_config); xmlConfig.docPtr = docPtr; xmlConfig.configPtr = &camera_cfg; // 解析每个camera 的信息，并且在 sensor_probe[]数组中检查当前sensor 是否已经probe 过了 for (i = 0; i 2.4.3 hal层函数 sensor_probe() 下发 CFG_SINIT_PROBE 进入 sensor_probe()函数： 在函数中可以看出，首先会调用 sensor_load_library()加载vendor 中camera sensor的库文件。 接着通过 IOCTRL 向通过下发 CFG_SINIT_PROBE消息，通知驱动层作probe 初始化。 /** sensor_probe: probe available sensors * @fd: sensor_init fd * @sensor_name: sensor name * Return: TRUE for success and FALSE for failure * 1) Open sensor library * 2) Pass slave information, probe sensor * 3) If probe succeeds, create video node and sensor subdev is * created in kernel **/ static boolean sensor_probe(module_sensor_ctrl_t *module_ctrl, int32_t fd, const char *sensor_name, char *path, struct xmlCameraConfigInfo *xmlConfig, boolean is_stereo_config, boolean bypass_video_node_creation) { /* Load sensor library */ rc = sensor_load_library(sensor_name, sensor_lib_params, path); ...... /* Pass slave information to kernel and probe */ memset(&cfg, 0, sizeof(cfg)); cfg.cfgtype = CFG_SINIT_PROBE; cfg.cfg.setting = slave_info; if (ioctl(fd, VIDIOC_MSM_SENSOR_INIT_CFG, &cfg) IOCTRL 命令定义如下： /* sensor init structures and enums */ enum msm_sensor_init_cfg_type_t { CFG_SINIT_PROBE, CFG_SINIT_PROBE_DONE, CFG_SINIT_PROBE_WAIT_DONE, }; 2.4.4 Kernel Ioctl 函数 msm_sensor_init_subdev_ioctl() 上层IOCTRL 命令下发到kernerl 中，进入msm_sensor_init_subdev_ioctl()中，接着转发到msm_sensor_driver_cmd()中，调用 msm_sensor_driver_probe()函数 \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor_init.c static long msm_sensor_init_subdev_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg) { switch (cmd) { case VIDIOC_MSM_SENSOR_INIT_CFG: rc = msm_sensor_driver_cmd(s_init, arg); break; } } /* Static function definition */ static int32_t msm_sensor_driver_cmd(struct msm_sensor_init_t *s_init, void *arg) { switch (cfg->cfgtype) { case CFG_SINIT_PROBE: mutex_lock(&s_init->imutex); s_init->module_init_status = 0; rc = msm_sensor_driver_probe(cfg->cfg.setting, &cfg->probed_info, cfg->entity_name); mutex_unlock(&s_init->imutex); if (rc module_init_status = 1; wake_up(&s_init->state_wait); break; case CFG_SINIT_PROBE_WAIT_DONE: msm_sensor_wait_for_probe_done(s_init); break; return rc; } 2.4.5 probe函数 msm_sensor_driver_probe() 从上层开始下发probe 命令，至此正式开始probe 初始化 camera，代码如下： 初始化并分配 slave_info 内存 将上层下发的 slave_info保存在 slave_info32 中 将 slave_info32 中的信息保存到 slave_info中。 打印 slave info 信息 通过camera id 获取到对应的 camera sensor ctrol 信息，也就是对应的camera 的dts 信息。 检测sensor 是否已经probe 过了，如果不是，直接跳过if 进行probe 获取camera的power settting 初始化 msm_camera_slave_info 结构体变量 camera_info ，用于保存 camera 的信息 配置camera i2c 相关信息 往s_ctrl 中填充 上下电相关信息 解析该camera 中所有外设 dts 节点信息 \"qcom,eeprom-src\"、\"qcom,actuator-src\"、\"qcom,led-flash-src\" 调用 sensor_power_up()给sensor 上电，开始probe sensor ,上电时调用 msm_sensor_check_id()，然后调用msm_sensor_match_id()检测 sensor id 是否区配。 创建对应的 /dev/videox 节点 及 /dev/mediax 的节点 probe 成功后下电 更新s_ctrl 结构体信息 kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor_driver.c int32_t msm_sensor_driver_probe(void *setting, struct msm_sensor_info_t *probed_info, char *entity_name) { struct msm_sensor_ctrl_t *s_ctrl = NULL; struct msm_camera_cci_client *cci_client = NULL; struct msm_camera_sensor_slave_info *slave_info = NULL; struct msm_camera_slave_info *camera_info = NULL; // 1. 初始化并分配 slave_info 内存 /* Allocate memory for slave info */ slave_info = kzalloc(sizeof(*slave_info), GFP_KERNEL); if (is_compat_task()) { // 2. 将上层下发的 slave_info保存在 slave_info32 中 struct msm_camera_sensor_slave_info32 *slave_info32 =kzalloc(sizeof(*slave_info32), GFP_KERNEL); copy_from_user((void *)slave_info32, setting, sizeof(*slave_info32)); // 3. 将 slave_info32 中的信息保存到 slave_info中。 strlcpy(slave_info->actuator_name, slave_info32->actuator_name, sizeof(slave_info->actuator_name)); strlcpy(slave_info->eeprom_name, slave_info32->eeprom_name, sizeof(slave_info->eeprom_name)); strlcpy(slave_info->sensor_name, slave_info32->sensor_name, sizeof(slave_info->sensor_name)); strlcpy(slave_info->ois_name, slave_info32->ois_name, sizeof(slave_info->ois_name)); strlcpy(slave_info->flash_name, slave_info32->flash_name, sizeof(slave_info->flash_name)); slave_info->addr_type = slave_info32->addr_type; slave_info->camera_id = slave_info32->camera_id; slave_info->i2c_freq_mode = slave_info32->i2c_freq_mode; slave_info->sensor_id_info = slave_info32->sensor_id_info; slave_info->slave_addr = slave_info32->slave_addr; slave_info->module_id_info = slave_info32->module_id_info; slave_info->power_setting_array.size = slave_info32->power_setting_array.size; slave_info->power_setting_array.size_down = slave_info32->power_setting_array.size_down; slave_info->power_setting_array.size_down = slave_info32->power_setting_array.size_down; slave_info->power_setting_array.power_setting = compat_ptr(slave_info32->power_setting_array.power_setting); slave_info->power_setting_array.power_down_setting = compat_ptr(slave_info32->power_setting_array.power_down_setting); slave_info->sensor_init_params = slave_info32->sensor_init_params; slave_info->output_format =slave_ info32->output_format; kfree(slave_info32); // 保存完毕合释放 slave_info32 内存。 } else #endif { if (copy_from_user(slave_info,(void *)setting, sizeof(*slave_info))) { pr_err(\"failed: copy_from_user\"); rc = -EFAULT; goto free_slave_info; } } // 4. 打印 slave info 信息 /* Print slave info */ CDBG(\"camera id %d Slave addr 0x%X addr_type %d\\n\", slave_info->camera_id, slave_info->slave_addr, slave_info->addr_type); CDBG(\"sensor_id_reg_addr 0x%X sensor_id 0x%X sensor id mask %d\", slave_info->sensor_id_info.sensor_id_reg_addr, slave_info->sensor_id_info.sensor_id,slave_info->sensor_id_info.sensor_id_mask); CDBG(\"power up size %d power down size %d\\n\",slave_info->power_setting_array.size,slave_info->power_setting_array.size_down); CDBG(\"position %d\",slave_info->sensor_init_params.position); CDBG(\"mount %d\",slave_info->sensor_init_params.sensor_mount_angle); // 5. 通过camera id 获取到对应的 camera sensor ctrol 信息，也就是对应的camera 的dts 信息。 /* Extract s_ctrl from camera id */ s_ctrl = g_sctrl[slave_info->camera_id]; CDBG(\"s_ctrl[%d] %pK\", slave_info->camera_id, s_ctrl); // 6. 检测sensor 是否已经probe 过了，如果不是，直接跳过if 进行probe if (s_ctrl->is_probe_succeed == 1) { /* * Different sensor on this camera slot has been connected * and probe already succeeded for that sensor. Ignore this * probe */ ...... } // 7. 获取camera的power settting rc = msm_sensor_get_power_settings(setting, slave_info,&s_ctrl->sensordata->power_info); // 8. 初始化 msm_camera_slave_info 结构体变量 camera_info ，用于保存 camera 的信息 camera_info = kzalloc(sizeof(struct msm_camera_slave_info), GFP_KERNEL); s_ctrl->sensordata->slave_info = camera_info; /* Fill sensor slave info */ camera_info->sensor_slave_addr = slave_info->slave_addr; camera_info->eeprom_slave_addr = slave_info->module_id_info.module_slave_id; camera_info->eeprom_module_reg_addr = slave_info->module_id_info.module_id_reg_addr; camera_info->eeprom_module_id = slave_info->module_id_info.module_id; camera_info->eeprom_master_id = slave_info->module_id_info.master_id; camera_info->sensor_id_reg_addr =slave_info->sensor_id_info.sensor_id_reg_addr; camera_info->sensor_id = slave_info->sensor_id_info.sensor_id; camera_info->sensor_id_mask = slave_info->sensor_id_info.sensor_id_mask; s_ctrl->sensor_i2c_client->addr_type = slave_info->addr_type; if (s_ctrl->sensor_i2c_client->client) s_ctrl->sensor_i2c_client->client->addr =camera_info->sensor_slave_addr; // 9. 配置camera i2c 相关信息。 cci_client = s_ctrl->sensor_i2c_client->cci_client; cci_client->cci_i2c_master = s_ctrl->cci_i2c_master; cci_client->sid = slave_info->slave_addr >> 1; cci_client->retries = 3; cci_client->id_map = 0; cci_client->i2c_freq_mode = slave_info->i2c_freq_mode; // 10. 往s_ctrl 中填充 上下电相关信息 /* Parse and fill vreg params for powerup settings */ rc = msm_camera_fill_vreg_params( s_ctrl->sensordata->power_info.cam_vreg, s_ctrl->sensordata->power_info.num_vreg, s_ctrl->sensordata->power_info.power_setting, s_ctrl->sensordata->power_info.power_setting_size); /* Parse and fill vreg params for powerdown settings*/ rc = msm_camera_fill_vreg_params( s_ctrl->sensordata->power_info.cam_vreg, s_ctrl->sensordata->power_info.num_vreg, s_ctrl->sensordata->power_info.power_down_setting, s_ctrl->sensordata->power_info.power_down_setting_size); CSID_TG: /* Update sensor, actuator and eeprom name in * sensor control structure */ s_ctrl->sensordata->sensor_name = slave_info->sensor_name; s_ctrl->sensordata->eeprom_name = slave_info->eeprom_name; s_ctrl->sensordata->actuator_name = slave_info->actuator_name; s_ctrl->sensordata->ois_name = slave_info->ois_name; s_ctrl->sensordata->flash_name = slave_info->flash_name; /* * Update eeporm subdevice Id by input eeprom name */ // 11. 解析该camera 中所有外设节点信息 \"qcom,eeprom-src\"、\"qcom,actuator-src\"、\"qcom,led-flash-src\" rc = msm_sensor_fill_eeprom_subdevid_by_name(s_ctrl); =====> src_node = of_parse_phandle(of_node, \"qcom,eeprom-src\", i); /* * Update actuator subdevice Id by input actuator name */ rc = msm_sensor_fill_actuator_subdevid_by_name(s_ctrl); =====> src_node = of_parse_phandle(of_node, \"qcom,actuator-src\", 0); rc = msm_sensor_fill_ois_subdevid_by_name(s_ctrl); rc = msm_sensor_fill_flash_subdevid_by_name(s_ctrl); =====> src_node = of_parse_phandle(of_node, \"qcom,led-flash-src\", 0); // 12. 调用 sensor_power_up() 给sensor 上电，开始probe sensor ,上电时调用 msm_sensor_check_id()，然后调用msm_sensor_match_id()检测sensor id 是否区配。 /* Power up and probe sensor */ rc = s_ctrl->func_tbl->sensor_power_up(s_ctrl); ==================> @ \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor.c for (retry = 0; retry sensor_i2c_client->i2c_func_tbl =&msm_sensor_secure_func_tbl; rc = msm_camera_power_up(power_info, s_ctrl->sensor_device_type, sensor_i2c_client); rc = msm_sensor_check_id(s_ctrl); ========> rc = msm_sensor_match_id(s_ctrl); sensor_device_type, sensor_i2c_client); msleep(20); continue; } else { break; } } sensor_name); /* * Create /dev/videoX node, comment for now until dummy /dev/videoX * node is created and used by HAL */ if (s_ctrl->sensor_device_type == MSM_CAMERA_PLATFORM_DEVICE) rc = msm_sensor_driver_create_v4l_subdev(s_ctrl); // 14. probe 成功后下电 /* Power down */ s_ctrl->func_tbl->sensor_power_down(s_ctrl); rc = msm_sensor_fill_slave_info_init_params(slave_info,s_ctrl->sensordata->sensor_info); rc = msm_sensor_validate_slave_info(s_ctrl->sensordata->sensor_info); /* Update sensor mount angle and position in media entity flag */ is_yuv = (slave_info->output_format == MSM_SENSOR_YCBCR) ? 1 : 0; mount_pos = ((s_ctrl->is_secure & 0x1) sensordata->sensor_info->position sensordata-> sensor_info->sensor_mount_angle / 90) msm_sd.sd.entity.flags = mount_pos | MEDIA_ENT_FL_DEFAULT; /*Save sensor info*/ s_ctrl->sensordata->cam_slave_info = slave_info; // 15. 更新s_ctrl 结构体信息 msm_sensor_fill_sensor_info(s_ctrl, probed_info, entity_name); /* * Set probe succeeded flag to 1 so that no other camera shall * probed on this slot */ s_ctrl->is_probe_succeed = 1; return rc; } 2.4.6 创建 /dev/videoX节点 msm_sensor_driver_create_v4l_subdev() \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\camera\\camera.c static int32_t msm_sensor_driver_create_v4l_subdev(struct msm_sensor_ctrl_t *s_ctrl) { int32_t rc = 0; uint32_t session_id = 0; // 1. 初始化 msm_video_device 结构体，调用video_register_device() 注册video 节点 rc = camera_init_v4l2(&s_ctrl->pdev->dev, &session_id); ===============> pvdev = kzalloc(sizeof(struct msm_video_device),GFP_KERNEL); pvdev->vdev = video_device_alloc(); v4l2_dev = kzalloc(sizeof(struct v4l2_device), GFP_KERNEL); rc = v4l2_device_register(dev, pvdev->vdev->v4l2_dev); strlcpy(pvdev->vdev->name, \"msm-sensor\", sizeof(pvdev->vdev->name)); pvdev->vdev->release = video_device_release; pvdev->vdev->fops = &camera_v4l2_fops; pvdev->vdev->ioctl_ops = &camera_v4l2_ioctl_ops; pvdev->vdev->minor = -1; pvdev->vdev->vfl_type = VFL_TYPE_GRABBER; rc = video_register_device(pvdev->vdev,VFL_TYPE_GRABBER, -1); *session = pvdev->vdev->num; video_set_drvdata(pvdev->vdev, pvdev); sensordata->sensor_info->session_id = session_id; /* Create /dev/v4l-subdevX device */ v4l2_subdev_init(&s_ctrl->msm_sd.sd, s_ctrl->sensor_v4l2_subdev_ops); snprintf(s_ctrl->msm_sd.sd.name, sizeof(s_ctrl->msm_sd.sd.name), \"%s\",s_ctrl->sensordata->sensor_name); v4l2_set_subdevdata(&s_ctrl->msm_sd.sd, s_ctrl->pdev); s_ctrl->msm_sd.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE; media_entity_init(&s_ctrl->msm_sd.sd.entity, 0, NULL, 0); s_ctrl->msm_sd.sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV; s_ctrl->msm_sd.sd.entity.group_id = MSM_CAMERA_SUBDEV_SENSOR; s_ctrl->msm_sd.sd.entity.name = s_ctrl->msm_sd.sd.name; s_ctrl->msm_sd.close_seq = MSM_SD_CLOSE_2ND_CATEGORY | 0x3; rc = msm_sd_register(&s_ctrl->msm_sd); if (rc msm_sd.sd.devnode->fops =&msm_sensor_v4l2_subdev_fops; return rc; } 2.5 struct msm_sensor_ctrl_t 结构体描述 \\kernel\\msm-4.4\\drivers\\media\\platform\\msm\\camera_v2\\sensor\\msm_sensor.h struct msm_sensor_ctrl_t { struct platform_device *pdev; struct mutex *msm_sensor_mutex; enum msm_camera_device_type_t sensor_device_type; struct msm_camera_sensor_board_info *sensordata; struct msm_sensor_power_setting_array power_setting_array; struct msm_sensor_packed_cfg_t *cfg_override; struct msm_sd_subdev msm_sd; enum cci_i2c_master_t cci_i2c_master; struct msm_camera_i2c_client *sensor_i2c_client; struct v4l2_subdev_info *sensor_v4l2_subdev_info; uint8_t sensor_v4l2_subdev_info_size; struct v4l2_subdev_ops *sensor_v4l2_subdev_ops; struct msm_sensor_fn_t *func_tbl; struct msm_camera_i2c_reg_setting stop_setting; void *misc_regulator; enum msm_sensor_state_t sensor_state; uint8_t is_probe_succeed; uint32_t id; struct device_node *of_node; enum msm_camera_stream_type_t camera_stream_type; uint32_t set_mclk_23880000; uint8_t is_csid_tg_mode; uint32_t is_secure; }; 至此，给合我们之前的移植过程，我们就将Kernel 中的 dts 相关的部分通过代码流程分析清楚了。 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "},"Sdm660_Camera/系统架构.html":{"url":"Sdm660_Camera/系统架构.html","title":"第 4 章：Camera 系统架构","keywords":"","body":"Camera 系统架构 看到一张好图，自：《sdm660–opencamera流程详细分析》 Camera模块的系统架构分为四层，从上到下分别是 Package 文件夹下的 Java 层 Framework 文件夹下的 Framework 层 Framework层下细分为：Java Framework、JNI Framework、Hardware Interface Framework 。 Hardware 文件夹下的 Hal 层 HAL 层下又细分为 Hardware Interface 与 mm-camera 层。 ADIL 是 JNI Framework 层 与 Hardware Interface Framework 层 交互的接口，即CameraClient 进程与 CameraService 进程的交互。 HIDL 是发生在 Framework 层 与 HAL*层交互的接口。 Kernel 文件夹下的 Driver 层 关于进程间通信的更多内容可以去看另一篇文档中Android机制部分的IPC。 接下来，我们进代码分析下 Camera Init 初始化流程。 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 15:10:34 "},"Sdm660_Camera/相机初始化流程.html":{"url":"Sdm660_Camera/相机初始化流程.html","title":"4.1 Camera Init 初始化流程","keywords":"","body":"Open Camera是Preview、TakePicture、Record的基础，Open Camera会初始化很多对象，而Preview等操作是围绕着这些对象进行操作的，所以这里用Open Camera来理清各个对象间的交互关系。 一、Camera Init 初始化流程 1.1 CameraService 启动 CameraService 是一个可执行程序放在 /system/bin/cameraserver，开机时通过init.rc 文件自启动。 frameworks/av/camera/cameraserver/cameraserver.rc service cameraserver /system/bin/cameraserver class main user cameraserver group audio camera input drmrpc ioprio rt 4 writepid /dev/cpuset/camera-daemon/tasks /dev/stune/foreground/tasks cameraserver 可执行程序代码如下： frameworks/av/camera/cameraserver/main_cameraserver.cpp #define LOG_TAG \"cameraserver\" //#define LOG_NDEBUG 0 #include \"CameraService.h\" using namespace android; int main(int argc __unused, char** argv __unused) { signal(SIGPIPE, SIG_IGN); sp proc(ProcessState::self()); sp sm = defaultServiceManager(); ALOGI(\"ServiceManager: %p\", sm.get()); CameraService::instantiate(); ProcessState::self()->startThreadPool(); IPCThreadState::self()->disableBackgroundScheduling(true); IPCThreadState::self()->joinThreadPool(); } 1.2 CameraService::instantiate() frameworks/native/include/binder/BinderService.h public: static status_t publish(bool allowIsolated = false) { sp sm(defaultServiceManager()); return sm->addService( String16(SERVICE::getServiceName()), new SERVICE(), allowIsolated); } static void instantiate() { publish(); } 这段代码的意思是，向 ServicIeManager添加 name 为 \"media.camera\"的service 。 String16(SERVICE::getServiceName()) =============> // Implementation of BinderService static char const* getServiceName() { return \"media.camera\"; } new SERVICE() =============> 相当于调用 new CameraService() 1.3 CameraService.cpp 由于是还 强指针的引用类型，代码new CameraService() ，在调用 CameraService::CameraService() 同时还会调用 void CameraService::onFirstRef()。 1.4 CameraService::CameraService() 主要工作如下： 定义全局 CameraService 指针对象 gCameraService 初始化变量 mNumberOfCameras = 0、mNumberOfNormalCameras = 0、mModule = NULL 将当前对象保存在 全局 CameraService 指针 gCameraService 中 frameworks/av/services/camera/libcameraservice/CameraService.cpp static CameraService *gCameraService; // 1. 定义全局 CameraService 指针对象 CameraService::CameraService() : mEventLog(DEFAULT_EVENT_LOG_LENGTH), mNumberOfCameras(0), mNumberOfNormalCameras(0), mSoundRef(0), mModule(nullptr) { ALOGI(\"CameraService started (pid=%d)\", getpid()); gCameraService = this; // 1. 将当前对象保存在 全局 CameraService 指针中 this->camera_device_status_change = android::camera_device_status_change; this->torch_mode_status_change = android::torch_mode_status_change; mServiceLockWrapper = std::make_shared(&mServiceLock); } 1.5 CameraService::onFirstRef() 主要工作如下： 加载 hal 层 camera module，保存在 rawModule 中 ，module定义在 hardware/libhardware/include/hardware/camera_common.h 初始化 CameraModule 对像，将 *camera_module_t rawModule 保存在 mModule 中 调用 Camera HAL module 的 init 方法，调用mModule->get_number_of_cameras()，用来设置 mCameraInfoMap vector 的容量 打印 hardware camera module 的 name ，hal 层代码定义在 hardware/qcom/camera/QCamera2/QCamera2Hal.cpp 获取 camera 个数，保存在CameraService 的私有变量 mNumberOfCameras 及 mNumberOfNormalCameras 中 初始化 CameraFlashlight 模块，根据 camera number 初始化 mHasFlashlightMap vector 数组变量 调用mModule->getCameraInfo() 返回hal 层mHalDescriptors 的信息，保存在 info 中 通过 BpCameraServiceProxy 远程调用 BnCameraService 的 pingForUserUpdate() 函数 frameworks/av/services/camera/libcameraservice/CameraService.cpp void CameraService::onFirstRef() { ALOGI(\"CameraService process starting\"); BnCameraService::onFirstRef(); // 1. 加载 hal 层 camera module，保存在 rawModule 中 // #define CAMERA_HARDWARE_MODULE_ID \"camera\" // module定义在 hardware/libhardware/include/hardware/camera_common.h camera_module_t *rawModule; int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,(const hw_module_t **)&rawModule); // 2. 初始化 CameraModule 对像，将 camera_module_t *rawModule 保存在 mModule 中 mModule = new CameraModule(rawModule); // 3. 调用 Camera HAL module 的 init 方法 // 从 hardware/libhardware/include/hardware/camera_common.h 中得知 // #define CAMERA_MODULE_API_VERSION_CURRENT CAMERA_MODULE_API_VERSION_2_4 // 因此，hal 层代码位于 hardware/qcom/camera/QCamera2/QCamera2Hal.cpp err = mModule->init(); ================> + @ frameworks/frameworks-new/av/services/camera/libcameraservice/common/CameraModule.cpp + int CameraModule::init() { + if (getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_4 && mModule->init != NULL) { + ATRACE_BEGIN(\"camera_module->init\"); + res = mModule->init(); // 从 QCamera2Hal.cpp 中得知，init = NULL + } + mCameraInfoMap.setCapacity(getNumberOfCameras()); // 设置CameraInfoMap vector的大小 + ==========> + numCameras = mModule->get_number_of_cameras(); + return res; + } getModuleName()); // \"QCamera Module\" // 5. 获取 camera 个数，保存在CameraService 的私有变量 mNumberOfCameras 及 mNumberOfNormalCameras 中 mNumberOfCameras = mModule->getNumberOfCameras(); mNumberOfNormalCameras = mNumberOfCameras; // 6. 初始化 CameraFlashlight 模块，根据 camera number 初始化 mHasFlashlightMap vector 数组变量 mFlashlight = new CameraFlashlight(*mModule, *this); status_t res = mFlashlight->findFlashUnits(); // 7. 调用mModule->getCameraInfo() int latestStrangeCameraId = INT_MAX; for (int i = 0; i getCameraInfo(i, &info); // 8. 返回 hardware 层 mHalDescriptors 的信息，保存在 info 中 // Defaults to use for cost and conflicting devices int cost = 100; char** conflicting_devices = nullptr; size_t conflicting_devices_length = 0; // If using post-2.4 module version, query the cost + conflicting devices from the HAL if (mModule->getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_4 && haveInfo) { cost = info.resource_cost; conflicting_devices = info.conflicting_devices; conflicting_devices_length = info.conflicting_devices_length; } std::set conflicting; for (size_t i = 0; i (cameraId, cost, conflicting)); } if (mFlashlight->hasFlashUnit(cameraId)) { mTorchStatusMap.add(cameraId, ICameraServiceListener::TORCH_STATUS_AVAILABLE_OFF); } } if (mModule->getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_1) { mModule->setCallbacks(this); } // 9. 通过 BpCameraServiceProxy 远程调用 BnCameraService 的 pingForUserUpdate() 函数 // 远程函数位于 IMPLEMENT_META_INTERFACE(CameraServiceProxy, \"android.hardware.ICameraServiceProxy\"); CameraService::pingCameraServiceProxy(); } 1.6 获取Camera数量 mModule->getNumberOfCameras() 进入hardware 层代码中： hardware/qcom/camera/QCamera2/QCamera2Hal.cpp camera_module_t HAL_MODULE_INFO_SYM = { .common = camera_common, .get_number_of_cameras = qcamera::QCamera2Factory::get_number_of_cameras, .get_camera_info = qcamera::QCamera2Factory::get_camera_info, .set_callbacks = qcamera::QCamera2Factory::set_callbacks, .get_vendor_tag_ops = qcamera::QCamera3VendorTags::get_vendor_tag_ops, .open_legacy = qcamera::QCamera2Factory::open_legacy, .set_torch_mode = qcamera::QCamera2Factory::set_torch_mode, .init = NULL, .reserved = {0} }; 首先初始化 gQCamera2Factory 对像，接着判断当前camera hal 层走 HAL1 还是 HAL3，调用对应的接口。 camera 个数是直接返回的变量mNumOfCameras_expose，而 mNumOfCameras_expose 变量是在 gQCamera2Factory() 中赋值的。 接着，通过判定是否支持 双摄，来调用不同的 getNumberOfCameras() 函数 hardware/qcom/camera/QCamera2/QCamera2Factory.cpp int QCamera2Factory::get_number_of_cameras() { int numCameras = 0; if (!gQCamera2Factory) { gQCamera2Factory = new QCamera2Factory(); } #ifdef QCAMERA_HAL1_SUPPORT if(gQCameraMuxer) numCameras = gQCameraMuxer->get_number_of_cameras(); else #endif numCameras = gQCamera2Factory->getNumberOfCameras(); =======> return mNumOfCameras_expose; LOGH(\"num of cameras: %d\", numCameras); return numCameras; } 接下来进入函数 QCamera2Factory() 看下： 打开/dev/mediax 节点 获取camera 的个数，保存在g_cam_ctrl.num_cam 返回 g_cam_ctrl.num_cam_to_expose = g_cam_ctrl.num_cam - is_secure; ，此处我们没有 secure ，所就它就是camera 个数 判断当前Camera系统 是否支待 HAL3，且如果没有定义QCAMERA_HAL1_SUPPORT ,则默认支持 HAL3 判断当前Camera系统是否支持双摄，如果是走HAL3 ，即未定义QCAMERA_HAL1_SUPPORT ，默认不支待双摄 判断当前Camera系统中所有camera是否走的是HAL3， YUV sensor是只能走HAL1 了 更新 mHalDescriptors 中每个camear id 所对应的 HAL API VERSION QCamera2Factory::QCamera2Factory() { mHalDescriptors = NULL; mCallbacks = NULL; mNumOfCameras = get_num_of_cameras(); // 1. 打开/dev/mediax 节点 获取camera 的个数，保存在g_cam_ctrl.num_cam mNumOfCameras_expose = get_num_of_cameras_to_expose(); // 2. 返回 g_cam_ctrl.num_cam_to_expose = g_cam_ctrl.num_cam - is_secure; ，此处我们没有 secure ，所就它就是camera 个数 int bDualCamera = 0; char propDefault[PROPERTY_VALUE_MAX]; char prop[PROPERTY_VALUE_MAX]; // 3. 判断当前Camera系统 是否支待 HAL3，且如果没有定义QCAMERA_HAL1_SUPPORT ,则默认支持 HAL3 property_get(\"persist.camera.HAL3.enabled\", prop, \"0\"); int isHAL3Enabled = atoi(prop); #ifndef QCAMERA_HAL1_SUPPORT isHAL3Enabled = 1; #endif // 4. 判断当前Camera系统是否支持双摄，如果是走HAL3 ，即未定义QCAMERA_HAL1_SUPPORT ，默认不支待双摄 // Signifies whether system has to enable dual camera mode snprintf(propDefault, PROPERTY_VALUE_MAX, \"%d\", isDualCamAvailable(isHAL3Enabled)); property_get(\"persist.camera.dual.camera\", prop, \"0\"); bDualCamera = atoi(prop); LOGH(\"dualCamera:%d \", bDualCamera); #ifndef QCAMERA_HAL1_SUPPORT bDualCamera = 0; #endif if(bDualCamera) { LOGI(\"Enabling QCamera Muxer\"); #ifdef QCAMERA_HAL1_SUPPORT if (!gQCameraMuxer) { QCameraMuxer::getCameraMuxer(&gQCameraMuxer, mNumOfCameras); if (!gQCameraMuxer) { LOGE(\"Error !! Failed to get QCameraMuxer\"); } } #endif } #ifdef QCAMERA_HAL1_SUPPORT if (!gQCameraMuxer && (mNumOfCameras > 0) &&(mNumOfCameras 0) &&(mNumOfCameras 1.7 hardware层调用 get_num_of_cameras() 打开 /dev/media0 -->（msm_config）msm_sensor_init /dev/media1 ---->（msm_camera）v4l2 调用 MEDIA_IOC_DEVICE_INFO 获取设备信息 如果判断不是 msm_config 则直接continue 寻找 entity.id = 2 的所有subdev ，且 type=MEDIA_ENT_T_V4L2_SUBDEV , group_id=14 , name = \"msm_sensor_init\" 找开 /dev/media0 /dev/media1 ... ，开始查找camear 个数，保存在 g_cam_ctrl.num_cam 中 如果判断不是 msm_config 则直接continue 遍历 V4L2 下camear 的个数 获取所有信息，保存在 g_cam_ctrl 中 hardware/qcom/camera/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c uint8_t get_num_of_cameras() { struct media_device_info mdev_info; int num_media_devices = 0; int8_t num_cameras = 0; char subdev_name[32]; char prop[PROPERTY_VALUE_MAX]; LOGD(\"E\"); memset (&g_cam_ctrl, 0, sizeof (g_cam_ctrl)); while (1) { uint32_t num_entities = 1U; char dev_name[32]; // 1. 打开 /dev/media0 -->（msm_config）msm_sensor_init /dev/media1 ---->（msm_camera）v4l2 snprintf(dev_name, sizeof(dev_name), \"/dev/media%d\", num_media_devices); dev_fd = open(dev_name, O_RDWR | O_NONBLOCK); num_media_devices++; // 2. 调用 MEDIA_IOC_DEVICE_INFO 获取设备信息 rc = ioctl(dev_fd, MEDIA_IOC_DEVICE_INFO, &mdev_info); ===============> + // kernel/msm-4.4/drivers/media/media-device.c + static long media_device_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){ + switch (cmd) { + case MEDIA_IOC_DEVICE_INFO: + ret = media_device_get_info(dev, (struct media_device_info __user *)arg); + ============> + - strlcpy(info.driver, dev->dev->driver->name, sizeof(info.driver)); + - strlcpy(info.model, dev->model, sizeof(info.model)); + - strlcpy(info.serial, dev->serial, sizeof(info.serial)); + - strlcpy(info.bus_info, dev->bus_info, sizeof(info.bus_info)); + - + - info.media_version = MEDIA_API_VERSION; + - info.hw_revision = dev->hw_revision; + - info.driver_version = dev->driver_version; + - copy_to_user(__info, &info, sizeof(*__info)) + + media_device_enum_entities(dev, (struct media_entity_desc __user *)arg); + -------> + pvdev->vdev->entity.type = MEDIA_ENT_T_DEVNODE_V4L; // V4L + pvdev->vdev->entity.group_id = QCAMERA_VNODE_GROUP_ID; // #define QCAMERA_VNODE_GROUP_ID 2 + = MM_CAMERA_MAX_NUM_SENSORS) { LOGW(\"Maximum number of camera reached %d\", num_cameras); break; } } g_cam_ctrl.num_cam = num_cameras; // 8. 获取所有信息，保存在 g_cam_ctrl 中 get_sensor_info(); // 9. 重新整理 g_cam_ctrl 中的camear 顺序，确保 后摄inx 比前摄大 /* Order of the camera exposed is 0 - Back Main Camera 1 - Front Main Camera ++ - Back Aux Camera ++ - Front Aux Camera ++ - Back Main + Back Aux camera ++ - Front Main + Front Aux camera ++ - Secure Camera */ sort_camera_info(g_cam_ctrl.num_cam); /* unlock the mutex */ LOGI(\"num_cameras=%d\\n\", (int)g_cam_ctrl.num_cam); return(uint8_t)g_cam_ctrl.num_cam; } 1.8 Camera Init 初始化流程总结 在Init 整个过程中，主要做了如下事情： 定义全局 CameraService 指针对象 gCameraService。 加载 hal 层 camera module，保存在 rawModule 中 ，module定义在hardware/libhardware/include/hardware/camera_common.h。 调用Camera hardware module 的mModule->get_number_of_cameras()，获得Camera Number。 调用 MEDIA_IOC_DEVICE_INFO 获取驱动层 Camera V4L2 的所有设备信息。 同时初始化 hardware 层的 mHalDescriptors 数组，更新每个Camera 使用的 camera hal1 还是 hal3。 二、hw_get_module() 在前面代码中，主要是通过 hw_get_module(CAMERA_HARDWARE_MODULE_ID,(const hw_module_t **)&rawModule) 来获取到驱动层的相关接口。 接下来，我们来看下 hw_get_module 具体做了什么操作： @ hardware/libhardware/hardware.c int hw_get_module(const char *id, const struct hw_module_t **module) { return hw_get_module_by_class(id, NULL, module); } 由此可知，CameraService.cpp 中调用hw_get_module，传递的参数为 CAMERA_HARDWARE_MODULE_ID 和 &rawModule #define CAMERA_HARDWARE_MODULE_ID \"camera\" 进入 hw_get_module_by_class() 分析下: id = \"camera\"、inst = NULL、module = &rawModule 拼凑出 PATH_MAX = \"camera\" hardware/libhardware/hardware.c int hw_get_module_by_class(const char *class_id, const char *inst, const struct hw_module_t **module) { int i = 0; char prop[PATH_MAX] = {0}; char path[PATH_MAX] = {0}; char name[PATH_MAX] = {0}; char prop_name[PATH_MAX] = {0}; // 1. 拼凑出 PATH_MAX = \"camera\" if (inst) snprintf(name, PATH_MAX, \"%s.%s\", class_id, inst); else strlcpy(name, class_id, PATH_MAX); // 2. 拼凑出 prop_name = \"ro.hardware.camera\" /* First try a property specific to the class and possibly instance */ snprintf(prop_name, sizeof(prop_name), \"ro.hardware.%s\", name); if (property_get(prop_name, prop, NULL) > 0) { if (hw_module_exists(path, sizeof(path), name, prop) == 0) { goto found; } } /* Loop through the configuration variants looking for a module */ for (i=0 ; i 可以看出，在hardware.c 中，在如下三个目录依次查找 ”camera.sdm660.so“ ，找到后，接下来load 库文件 // @ hardware/libhardware/hardware.c #define HAL_LIBRARY_PATH1 \"/system/lib64/hw\" #define HAL_LIBRARY_PATH2 \"/vendor/lib64/hw\" #define HAL_LIBRARY_PATH3 \"/odm/lib64/hw\" /* * Check if a HAL with given name and subname exists, if so return 0, otherwise * otherwise return negative. On success path will contain the path to the HAL. */ static int hw_module_exists(char *path, size_t path_len, const char *name, const char *subname) { snprintf(path, path_len, \"%s/%s.%s.so\", HAL_LIBRARY_PATH3, name, subname); if (access(path, R_OK) == 0) return 0; snprintf(path, path_len, \"%s/%s.%s.so\", HAL_LIBRARY_PATH2, name, subname); if (access(path, R_OK) == 0) return 0; snprintf(path, path_len, \"%s/%s.%s.so\", HAL_LIBRARY_PATH1, name, subname); if (access(path, R_OK) == 0) return 0; return -ENOENT; } 2.1 camera.sdm660.so camera.sdm660.so 文件代码位于 hardware/qcom/camera/QCamera2/ # Enable SDLLVM compiler option for build flavour >= N flavour PLATFORM_SDK_NPDK = 24 LOCAL_COPY_HEADERS_TO := qcom/camera LOCAL_COPY_HEADERS := QCameraFormat.h LOCAL_SRC_FILES := \\ util/QCameraBufferMaps.cpp \\ util/QCameraCmdThread.cpp \\ util/QCameraFlash.cpp \\ util/QCameraPerf.cpp \\ util/QCameraQueue.cpp \\ util/QCameraCommon.cpp \\ util/QCameraTrace.cpp \\ util/camscope_packet_type.cpp \\ QCamera2Hal.cpp \\ QCamera2Factory.cpp #HAL 3.0 source LOCAL_SRC_FILES += \\ HAL3/QCamera3HWI.cpp \\ HAL3/QCamera3Mem.cpp \\ HAL3/QCamera3Stream.cpp \\ HAL3/QCamera3Channel.cpp \\ HAL3/QCamera3VendorTags.cpp \\ HAL3/QCamera3PostProc.cpp \\ HAL3/QCamera3CropRegionMapper.cpp \\ HAL3/QCamera3StreamMem.cpp LOCAL_CFLAGS := -Wall -Wextra -Werror #HAL 1.0 source ifeq ($(TARGET_SUPPORT_HAL1),false) LOCAL_CFLAGS += -DQCAMERA_HAL3_SUPPORT else LOCAL_CFLAGS += -DQCAMERA_HAL1_SUPPORT LOCAL_SRC_FILES += \\ HAL/QCamera2HWI.cpp \\ HAL/QCameraMuxer.cpp \\ HAL/QCameraMem.cpp \\ HAL/QCameraStateMachine.cpp \\ util/QCameraDisplay.cpp \\ HAL/QCameraChannel.cpp \\ HAL/QCameraStream.cpp \\ HAL/QCameraPostProc.cpp \\ HAL/QCamera2HWICallbacks.cpp \\ HAL/QCameraParameters.cpp \\ HAL/QCameraParametersIntf.cpp \\ HAL/QCameraThermalAdapter.cpp \\ util/QCameraFOVControl.cpp \\ util/QCameraHALPP.cpp \\ util/QCameraDualFOVPP.cpp \\ util/QCameraExtZoomTranslator.cpp \\ util/QCameraPprocManager.cpp \\ util/QCameraBokeh.cpp \\ util/QCameraClearSight.cpp endif LOCAL_MODULE_RELATIVE_PATH := hw LOCAL_MODULE := camera.$(TARGET_BOARD_PLATFORM) LOCAL_MODULE_TAGS := optional LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY) include $(BUILD_SHARED_LIBRARY) copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 15:24:17 "},"Sdm660_Camera/open_Camera流程.html":{"url":"Sdm660_Camera/open_Camera流程.html","title":"第 5 章：open_Camera 流程","keywords":"","body":"Camera Open 总结 整个Camera Open 过程总结如下： 一、Java APP 层 调用 Frameworks 层 Camera.java 中的 open() 方法； 在open camera 后，才开始调用对应的 getParameters()，setParameters()， startPreview() 等 函数； 二、Framework层 Camera.java 中的 open() 在Camera open() 函数中，如果没有指定open 对应的camera id，则默认打开后摄 根据传入的 camera id 进行初始化 注册 EventHandler 循环监听Camera 事件 调用 native_setup() JNI 函数，并下发 camera id 、当前包名、hal层版本号 三、JNI 层 android_hardware_Camera_native_setup 调用 Camera::connect() 函数，connect 为 AIDL 方法，通过binder 调用到服务端CameraService.cpp中的 CameraService::connect() 方法中 获取 Camera Class，建立专门负责与java Camera对象通信的对象 如果没有设置屏幕显示方向，则默认为0，如果不为0，调用sendCommand 下发屏幕显示方向 四、C++ Native 层 CameraService.cpp 中 CameraService.cpp 是camera 初始化中讲过了，在开机时会注册好对应的 cameraservice 服务 前面AIDL中，调用到 CameraService.cpp中的 CameraService::connect() 方法 在该方法中， 首先检查是否存在 client ，如果存在的话直接返回 关闭所有的 flashlight 对象 调用makeClient() 创建 Camera Client 对象。 client是通过 Camera2ClientBase() 进行创建的，同时创建Camera3Device 对象 调用client->initialize对前面创建好的 Camera client 进行初始化 初始化前先对device 进行初始化 ，在Camera3Device->initialize()中打开对应的 Camera 节点/dev/videox，进行初始化，获取到 Camera 的操作方法 初始化 Camera 默认参数 接着对创建 Camera 运行时的六大线程，处理preview和录像 stream的线程、处理3A和人脸识别的线程、拍照流程状态机线程、处理拍照 jpeg stream 线程、处理零延时zsl stream使用的线程、处理callback的线程 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "},"Sdm660_Camera/open_Camera代码分析.html":{"url":"Sdm660_Camera/open_Camera代码分析.html","title":"5.1 open_Camera 代码分析","keywords":"","body":"Camera Open 流程 一、Java 层 Camera Class 使用介绍 先看下谷歌官方对 Camera Class 的介绍： The Camera class is used to set image capture settings, start/stop preview, snap pictures, and retrieve frames for encoding for video. This Class is a client for the Camera service, which manages the actual camera hardware. To access the device camera, you must declare the {@link android.Manifest.permission#CAMERA} permission in your Android Manifest. Also be sure to include the uses-feature manifest element to declare camera features used by your application. For example, if you use the camera and auto-focus feature, your Manifest should include the following: uses-permission android:name = “android.permission.CAMERA” uses-feature android:name = “android.hardware.camera” uses-feature android:name = \"android.hardware.camera.autofocus\" 1.1 拍照官方流程 通过open(int)获取一个Camera实例。 使用getParameters()取得现有的设置（例如默认分辨率、帧率等 ）。 设置并下发 Camera 参数。如果有必要，修改返回的Camera.Parameters，并调用setParameters(Camera.Parameters)。 设置屏幕显示方向，如果需要，调用setDisplayOrientation(int)。 传递一个完全初始化的 SurfaceHolder，调用setPreviewDisplay(SurfaceHolder)，否则无法预览。 调用 startPreview() 开始预览，拍照之前必须先预览。 调用takePicture() 开始拍照时，等待它的回调函数回传数据。 takePicture(Camera.ShutterCallback,Camera.PictureCallback, Camera.PictureCallback, Camera.PictureCallback) 拍照完后，preview会停止，如果想继续拍照，需重新调用 startPreview()。 调用stopPreview()停止更新预览界面。 调用 release() 释放Camera 资源。 1.2 录像官方流程 获取并初始化 Camera 对像，并调用 startPreview()。 调用 unlock() 允许 media 进程操作Camera。 调用 setCamera(Camera) 将 Camera 对像传递给 MediaRecorder。 当录像完毕后，调用 reconnect() 重新锁定Camera。 如果想拍照，重新preview ，然后拍照。 调用 stopPreview() 和 release() 退出预览并释放Camera资源。 二、 Frameworks 层 Camera.java 分析 Java 层中调用的 Camera Class 源码位于 frameworks/base/core/java/android/hardware/Camera.java frameworks/base/core/java/android/hardware/Camera.java public class Camera { private static final String TAG = \"Camera\"; private CameraDataCallback mCameraDataCallback; private CameraMetaDataCallback mCameraMetaDataCallback; public static final int CAMERA_HAL_API_VERSION_1_0 = 0x100; public static class CameraInfo { public static final int CAMERA_FACING_BACK = 0; public static final int CAMERA_FACING_FRONT = 1; public static final int CAMERA_SUPPORT_MODE_ZSL = 2; public static final int CAMERA_SUPPORT_MODE_NONZSL = 3; public int facing; public int orientation; public boolean canDisableShutterSound; }; // 1. 找开指定 id 的Camera public static Camera open(int cameraId) { return new Camera(cameraId); } // 2. 在Camera open() 函数中，如果没有指定open 对应的camera id，则默认打开后摄 public static Camera open() { int numberOfCameras = getNumberOfCameras(); CameraInfo cameraInfo = new CameraInfo(); for (int i = 0; i 0) { TextUtils.StringSplitter splitter = new TextUtils.SimpleStringSplitter(','); splitter.setString(packageList); for (String str : splitter) { if (packageName.equals(str)) { halVersion = CAMERA_HAL_API_VERSION_1_0; break; } } } // 4. 调用 native_setup() JNI 函数，并下发 camera id 、当前包名、hal层版本号 return native_setup(new WeakReference(this), cameraId, halVersion, packageName); } 2.1 【JNI】 CameraService初始化 native_setup( ) —> android_hardware_Camera_native_setup( ) java 中通过JNI 调用 native 方法，Camera JNI 代码位于 //cameraId = 0 //halVersion = -2 native_setup(new WeakReference(this), cameraId, halVersion, packageName); @ frameworks/base/core/jni/android_hardware_Camera.cpp static const JNINativeMethod camMethods[] = { { \"_getNumberOfCameras\", \"()I\", (void *)android_hardware_Camera_getNumberOfCameras }, { \"_getCameraInfo\", \"(ILandroid/hardware/Camera$CameraInfo;)V\", (void*)android_hardware_Camera_getCameraInfo }, { \"native_setup\", \"(Ljava/lang/Object;IILjava/lang/String;)I\", (void*)android_hardware_Camera_native_setup }, { \"native_release\", \"()V\", (void*)android_hardware_Camera_release }, { \"setPreviewSurface\", \"(Landroid/view/Surface;)V\", (void *)android_hardware_Camera_setPreviewSurface }, { \"setPreviewTexture\", \"(Landroid/graphics/SurfaceTexture;)V\", (void *)android_hardware_Camera_setPreviewTexture }, { \"setPreviewCallbackSurface\", \"(Landroid/view/Surface;)V\", (void *)android_hardware_Camera_setPreviewCallbackSurface }, { \"startPreview\", \"()V\", (void *)android_hardware_Camera_startPreview }, { \"_stopPreview\", \"()V\", (void *)android_hardware_Camera_stopPreview }, { \"previewEnabled\", \"()Z\", (void *)android_hardware_Camera_previewEnabled }, { \"setHasPreviewCallback\",\"(ZZ)V\", (void *)android_hardware_Camera_setHasPreviewCallback }, { \"_addCallbackBuffer\", \"([BI)V\", (void *)android_hardware_Camera_addCallbackBuffer }, { \"native_autoFocus\", \"()V\", (void *)android_hardware_Camera_autoFocus }, { \"native_cancelAutoFocus\",\"()V\", (void *)android_hardware_Camera_cancelAutoFocus }, { \"native_takePicture\", \"(I)V\", (void *)android_hardware_Camera_takePicture }, { \"native_setHistogramMode\",\"(Z)V\", (void *)android_hardware_Camera_setHistogramMode }, { \"native_setMetadataCb\", \"(Z)V\", (void *)android_hardware_Camera_setMetadataCb }, { \"native_sendHistogramData\",\"()V\", (void *)android_hardware_Camera_sendHistogramData }, { \"native_setLongshot\", \"(Z)V\", (void *)android_hardware_Camera_setLongshot }, { \"native_setParameters\", \"(Ljava/lang/String;)V\", (void *)android_hardware_Camera_setParameters }, { \"native_getParameters\", \"()Ljava/lang/String;\", (void *)android_hardware_Camera_getParameters }, { \"reconnect\", \"()V\", (void*)android_hardware_Camera_reconnect }, { \"lock\", \"()V\", (void*)android_hardware_Camera_lock }, { \"unlock\", \"()V\", (void*)android_hardware_Camera_unlock }, { \"startSmoothZoom\", \"(I)V\", (void *)android_hardware_Camera_startSmoothZoom }, { \"stopSmoothZoom\", \"()V\", (void *)android_hardware_Camera_stopSmoothZoom }, { \"setDisplayOrientation\",\"(I)V\", (void *)android_hardware_Camera_setDisplayOrientation }, { \"_enableShutterSound\", \"(Z)Z\", (void *)android_hardware_Camera_enableShutterSound }, { \"_startFaceDetection\", \"(I)V\", (void *)android_hardware_Camera_startFaceDetection }, { \"_stopFaceDetection\", \"()V\", (void *)android_hardware_Camera_stopFaceDetection}, { \"enableFocusMoveCallback\",\"(I)V\", (void *)android_hardware_Camera_enableFocusMoveCallback}, }; // connect to camera service static jint android_hardware_Camera_native_setup(JNIEnv *env, jobject thiz, jobject weak_this, jint cameraId, jint halVersion, jstring clientPackageName) { // Convert jstring to String16 const char16_t *rawClientName = reinterpret_cast(env->GetStringChars(clientPackageName, NULL)); jsize rawClientNameLen = env->GetStringLength(clientPackageName); String16 clientName(rawClientName, rawClientNameLen); env->ReleaseStringChars(clientPackageName, reinterpret_cast(rawClientName)); sp camera; if (halVersion == CAMERA_HAL_API_VERSION_NORMAL_CONNECT) { // -2 // Default path: hal version is don't care, do normal camera connect. // 调用 Camera::connect() 函数，connect 为 AIDL 方法， // 通过binder 调用到服务端CameraService.cpp中的 CameraService::connect() 方法中 camera = Camera::connect(cameraId, clientName, Camera::USE_CALLING_UID, Camera::USE_CALLING_PID); ======================> + // frameworks/av/camera/Camera.cpp + return CameraBaseT::connect(cameraId, clientPackageName, clientUid, clientPid); + ========> + // frameworks/av/camera/CameraBase.cpp + sp CameraBase::connect(int cameraId, const String16& clientPackageName, int clientUid, int clientPid) + { + - sp c = new TCam(cameraId); + - sp cl = c; + const sp cs = getCameraService(); + TCamConnectService fnConnectService = TCamTraits::fnConnectService; + ret = (cs.get()->*fnConnectService)(cl, cameraId, clientPackageName, clientUid, clientPid, /*out*/ &c->mCamera); + ---------> + CameraTraits::TCamConnectService CameraTraits::fnConnectService = + &::android::hardware::ICameraService::connect; + + IInterface::asBinder(c->mCamera)->linkToDeath(c); + return c; + } + getStatus() != NO_ERROR) { return NO_INIT; } // 获取 Camera Class jclass clazz = env->GetObjectClass(thiz); if (clazz == NULL) { // This should never happen jniThrowRuntimeException(env, \"Can't find android/hardware/Camera\"); return INVALID_OPERATION; } // We use a weak reference so the Camera object can be garbage collected. // The reference is only used as a proxy for callbacks. sp context = new JNICameraContext(env, weak_this, clazz, camera); context->incStrong((void*)android_hardware_Camera_native_setup); camera->setListener(context); // 专门负责与java Camera对象通信的对象 // save context in opaque field env->SetLongField(thiz, fields.context, (jlong)context.get()); // Update default display orientation in case the sensor is reverse-landscape CameraInfo cameraInfo; status_t rc = Camera::getCameraInfo(cameraId, &cameraInfo); int defaultOrientation = 0; switch (cameraInfo.orientation) { case 0: break; case 90: if (cameraInfo.facing == CAMERA_FACING_FRONT) { defaultOrientation = 180; } break; case 180: defaultOrientation = 180; break; case 270: if (cameraInfo.facing != CAMERA_FACING_FRONT) { defaultOrientation = 180; } break; default: ALOGE(\"Unexpected camera orientation %d!\", cameraInfo.orientation); break; } // 如果没有设置屏幕显示方向，则默认为0，如果不为0，调用sendCommand 下发屏幕显示方向 if (defaultOrientation != 0) { ALOGV(\"Setting default display orientation to %d\", defaultOrientation); rc = camera->sendCommand(CAMERA_CMD_SET_DISPLAY_ORIENTATION,defaultOrientation, 0); } return NO_ERROR; } 2.2 【AIDL】接口ICameraService 在前面代码中， 经过如下一系列调用，最终走到了 AIDL 层。 native_setup() → android_hardware_Camera_native_setup() → CameraBaseT::connect → sp CameraBase::connect → ret = (cs.get()->fnConnectService) → android::hardware::ICameraService::connect() fnConnectService 定义如下： CameraTraits::TCamConnectService CameraTraits::fnConnectService = &::android::hardware::ICameraService::connect; frameworks/av/camera/aidl/android/hardware/ICameraService.aidl /** * Binder interface for the native camera service running in mediaserver. * @hide */ interface ICameraService { /** Open a camera device through the old camera API */ ICamera connect(ICameraClient client, int cameraId, String opPackageName, int clientUid, int clientPid); /** Open a camera device through the new camera API Only supported for device HAL versions >= 3.2 */ ICameraDeviceUser connectDevice(ICameraDeviceCallbacks callbacks, int cameraId,String opPackageName,int clientUid); } AIDL 中，我们走的是老方法， ICamera connect(). Android Interface Definition Language,是一种接口定义语言，用于生成可以在Android设备上两个进程间进行通信的代码。 Android Java Service Framework提供的大多数系统服务都是使用AIDL语言生成的。使用AIDL语言，可以自动生成服务接口、服务代理、服务Stub代码。 2.3 【原生】CameraService.cpp 通过 AIDL 的 Binder 通信，跳转到 CameraService.cpp 中。 CameraService.cpp 是camera 初始化中，在开机时会注册好对应的 cameraservice 服务。 此时就是通过Binder通信，调用CameraService 服务中的 connect 方法： frameworks/av/services/camera/libcameraservice/CameraService.cpp Status CameraService::connect( const sp& cameraClient, int cameraId, const String16& clientPackageName, int clientUid, int clientPid, /*out*/ sp* device) { String8 id = String8::format(\"%d\", cameraId); sp client = nullptr; ret = connectHelper(cameraClient, id, CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, clientPid, API_1, /*legacyMode*/ false, /*shimUpdateOnly*/ false, /*out*/client); *device = client; return ret; } 进入 connectHelper 函数看下： 检查 Client 的权限 如果已存在 client 则直接返回 在打开Camera 前，所有Flashlight 都应该被关闭 调用makeClient() 创建 Camera Client 对象。 client是通过 Camera2ClientBase() 进行创建的，同时创建Camera3Device 对象 调用client->initialize对前面创建好的 Camera client 进行初始化 template binder::Status CameraService::connectHelper(const sp& cameraCb, const String8& cameraId, int halVersion, const String16& clientPackageName, int clientUid, int clientPid, apiLevel effectiveApiLevel, bool legacyMode, bool shimUpdateOnly, /*out*/sp& device) { binder::Status ret = binder::Status::ok(); String8 clientName8(clientPackageName); int originalClientPid = 0; ALOGI(\"CameraService::connect call (PID %d \\\"%s\\\", camera ID %s) for HAL version %s and \" \"Camera API version %d\", clientPid, clientName8.string(), cameraId.string(), (halVersion == -1) ? \"default\" : std::to_string(halVersion).c_str(), static_cast(effectiveApiLevel)); sp client = nullptr; { // 1. 检查 Client 的权限 // Enforce client permissions and do basic sanity checks if(!(ret = validateConnectLocked(cameraId, clientName8, /*inout*/clientUid, /*inout*/clientPid, /*out*/originalClientPid)).isOk()) { return ret; } sp clientTmp = nullptr; std::shared_ptr>> partial; err = handleEvictionsLocked(cameraId, originalClientPid, effectiveApiLevel, IInterface::asBinder(cameraCb), clientName8, /*out*/&clientTmp, /*out*/&partial)); // 2. 如果已存在 client 则直接返回 if (clientTmp.get() != nullptr) { // Handle special case for API1 MediaRecorder where the existing client is returned device = static_cast(clientTmp.get()); return ret; } // 3. 在打开Camera 前，所有Flashlight 都应该被关闭 // give flashlight a chance to close devices if necessary. mFlashlight->prepareDeviceOpen(cameraId); // TODO: Update getDeviceVersion + HAL interface to use strings for Camera IDs int id = cameraIdToInt(cameraId); int facing = -1; int deviceVersion = getDeviceVersion(id, /*out*/&facing); sp tmp = nullptr; // 4. 调用makeClient() 创建 Camera Client 对象。 client是通过 Camera2ClientBase() 进行创建的，同时创建Camera3Device 对象 if(!(ret = makeClient(this, cameraCb, clientPackageName, id, facing, clientPid, clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel, /*out*/&tmp)).isOk()) { return ret; } client = static_cast(tmp.get()); // Camera2Client LOG_ALWAYS_FATAL_IF(client.get() == nullptr, \"%s: CameraService in invalid state\", __FUNCTION__); // 5. 调用client->initialize对前面创建好的 Camera client 进行初始化 if ((err = client->initialize(mModule)) != OK) { ALOGE(\"%s: Could not initialize client from HAL module.\", __FUNCTION__); // Errors could be from the HAL module open call or from AppOpsManager switch(err) { case BAD_VALUE: return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT, \"Illegal argument to HAL module for camera \\\"%s\\\"\", cameraId.string()); case -EBUSY: return STATUS_ERROR_FMT(ERROR_CAMERA_IN_USE, \"Camera \\\"%s\\\" is already open\", cameraId.string()); case -EUSERS: return STATUS_ERROR_FMT(ERROR_MAX_CAMERAS_IN_USE, \"Too many cameras already open, cannot open camera \\\"%s\\\"\", cameraId.string()); case PERMISSION_DENIED: return STATUS_ERROR_FMT(ERROR_PERMISSION_DENIED, \"No permission to open camera \\\"%s\\\"\", cameraId.string()); case -EACCES: return STATUS_ERROR_FMT(ERROR_DISABLED, \"Camera \\\"%s\\\" disabled by policy\", cameraId.string()); case -ENODEV: default: return STATUS_ERROR_FMT(ERROR_INVALID_OPERATION, \"Failed to initialize camera \\\"%s\\\": %s (%d)\", cameraId.string(), strerror(-err), err); } } // Update shim paremeters for legacy clients if (effectiveApiLevel == API_1) { // Assume we have always received a Client subclass for API1 sp shimClient = reinterpret_cast(client.get()); String8 rawParams = shimClient->getParameters(); CameraParameters params(rawParams); auto cameraState = getCameraState(cameraId); if (cameraState != nullptr) { cameraState->setShimParams(params); } else { ALOGE(\"%s: Cannot update shim parameters for camera %s, no such device exists.\", __FUNCTION__, cameraId.string()); } } if (shimUpdateOnly) { // If only updating legacy shim parameters, immediately disconnect client mServiceLock.unlock(); client->disconnect(); mServiceLock.lock(); } else { // Otherwise, add client to active clients list finishConnectLocked(client, partial); } } // lock is destroyed, allow further connect calls // Important: release the mutex here so the client can call back into the service from its // destructor (can be at the end of the call) device = client; return ret; } 2.3.1 【HAL】 创建 Camera 客户端 makeClient( ) 接着调用 makeClient(this, cameraCb, clientPackageName, id, facing, clientPid, clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel, /out/&tmp)) frameworks/av/services/camera/libcameraservice/CameraService.cpp Status CameraService::makeClient(const sp& cameraService, const sp& cameraCb, const String16& packageName, int cameraId, int facing, int clientPid, uid_t clientUid, int servicePid, bool legacyMode, int halVersion, int deviceVersion, apiLevel effectiveApiLevel, /*out*/sp* client) { if (halVersion tmp = static_cast(cameraCb.get()); *client = new CameraClient(cameraService, tmp, packageName, cameraId, facing, clientPid, clientUid, getpid(), legacyMode); } else { // Camera2 API route ALOGW(\"Camera using old HAL version: %d\", deviceVersion); return STATUS_ERROR_FMT(ERROR_DEPRECATED_HAL, \"Camera device \\\"%d\\\" HAL version %d does not support camera2 API\", cameraId, deviceVersion); } break; case CAMERA_DEVICE_API_VERSION_3_0: case CAMERA_DEVICE_API_VERSION_3_1: case CAMERA_DEVICE_API_VERSION_3_2: case CAMERA_DEVICE_API_VERSION_3_3: case CAMERA_DEVICE_API_VERSION_3_4: if (effectiveApiLevel == API_1) { // Camera1 API route sp tmp = static_cast(cameraCb.get()); *client = new Camera2Client(cameraService, tmp, packageName, cameraId, facing, clientPid, clientUid, servicePid, legacyMode); } else { // Camera2 API route sp tmp = static_cast(cameraCb.get()); *client = new CameraDeviceClient(cameraService, tmp, packageName, cameraId, facing, clientPid, clientUid, servicePid); } break; } } else { // A particular HAL version is requested by caller. Create CameraClient // based on the requested HAL version. if (deviceVersion > CAMERA_DEVICE_API_VERSION_1_0 && halVersion == CAMERA_DEVICE_API_VERSION_1_0) { // Only support higher HAL version device opened as HAL1.0 device. sp tmp = static_cast(cameraCb.get()); *client = new CameraClient(cameraService, tmp, packageName, cameraId, facing, clientPid, clientUid, servicePid, legacyMode); } else { // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet. ALOGE(\"Invalid camera HAL version %x: HAL %x device can only be\" \" opened as HAL %x device\", halVersion, deviceVersion, CAMERA_DEVICE_API_VERSION_1_0); return STATUS_ERROR_FMT(ERROR_ILLEGAL_ARGUMENT, \"Camera device \\\"%d\\\" (HAL version %d) cannot be opened as HAL version %d\", cameraId, deviceVersion, halVersion); } } return Status::ok(); } 接着调用 client = new Camera2Client(cameraService, tmp, packageName, cameraId, facing, clientPid, clientUid, servicePid, legacyMode); client是通过 Camera2ClientBase() 进行创建的 frameworks/av/services/camera/libcameraservice/api1/Camera2Client.cpp Camera2Client::Camera2Client(const sp& cameraService, const sp& cameraClient, const String16& clientPackageName, int cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid, bool legacyMode): Camera2ClientBase(cameraService, cameraClient, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid), mParameters(cameraId, cameraFacing) { ATRACE_CALL(); SharedParameters::Lock l(mParameters); l.mParameters.state = Parameters::DISCONNECTED; mLegacyMode = legacyMode; } 创建Camera3Device 对象 // Interface used by CameraService template Camera2ClientBase::Camera2ClientBase( const sp& cameraService, const sp& remoteCallback, const String16& clientPackageName, int cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid): TClientBase(cameraService, remoteCallback, clientPackageName,cameraId, cameraFacing, clientPid, clientUid, servicePid), mSharedCameraCallbacks(remoteCallback), mDeviceVersion(cameraService->getDeviceVersion(cameraId)), mDeviceActive(false) { ALOGI(\"Camera %d: Opened. Client: %s (PID %d, UID %d)\", cameraId, String8(clientPackageName).string(), clientPid, clientUid); mInitialClientPid = clientPid; mDevice = new Camera3Device(cameraId); LOG_ALWAYS_FATAL_IF(mDevice == 0, \"Device should never be NULL here.\"); } frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp Camera3Device::Camera3Device(int id): mId(id), mIsConstrainedHighSpeedConfiguration(false), mHal3Device(NULL), mStatus(STATUS_UNINITIALIZED), mStatusWaiters(0), mUsePartialResult(false), mNumPartialResults(1), mTimestampOffset(0), mNextResultFrameNumber(0), mNextReprocessResultFrameNumber(0), mNextShutterFrameNumber(0), mNextReprocessShutterFrameNumber(0), mListener(NULL) { ATRACE_CALL(); camera3_callback_ops::notify = &sNotify; camera3_callback_ops::process_capture_result = &sProcessCaptureResult; ALOGV(\"%s: Created device for camera %d\", __FUNCTION__, id); } 2.3.2 【HAL】 Camera2Client初始化 client->initialize(mModule)) 调用 Camera3Device::initialize 对/dev/videox 调备节点进行初始化，获取对应的设备的opt 操作函数 初始化 Camera 默认参数 创建 Camera 运行时的六大线程 StreamingProcessor：用来处理preview和录像 stream的线程。 FrameProcessor：用来处理3A和人脸识别的线程。 CaptureSequencer：拍照流程状态机线程，拍照的场景非常多，后面会发出状态机的运转流程。 JpegProcessor：用来处理拍照 jpeg stream 线程 ZslProcessor3：这个处理零延时zsl stream使用的线程 mCallbackProcessor：处理callback的线程，主要包含对 callback stream 的创建函数 updateStream()以及处理 HAL 层传上来的 callback stream 的线程 frameworks/av/services/camera/libcameraservice/api1/Camera2Client.cpp status_t Camera2Client::initialize(CameraModule *module) { ATRACE_CALL(); ALOGV(\"%s: Initializing client for camera %d\", __FUNCTION__, mCameraId); status_t res; // 1. 调用 Camera3Device::initialize 进行设备初始化,获取对应的 camera device 的opt 操作函数 res = Camera2ClientBase::initialize(module); ==============> @ frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp mDevice->initialize(module); mDevice->setNotifyCallback(weakThis); info()), mDeviceVersion); ================> + @ frameworks/av/services/camera/libcameraservice/api1/client2/Parameters.cpp + status_t Parameters::initialize(const CameraMetadata *info, int deviceVersion) { + ...... + videoWidth = previewWidth; + videoHeight = previewHeight; + params.setPreviewSize(previewWidth, previewHeight); + params.setVideoSize(videoWidth, videoHeight); + params.set(CameraParameters::KEY_PREFERRED_PREVIEW_SIZE_FOR_VIDEO, + String8::format(\"%dx%d\", previewWidth, previewHeight)); + params.set(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS, supportedPreviewFormats); + ...... 省略一系列 参数初始化代码 run(threadName.string()); // 3.2 FrameProcessor：用来处理3A和人脸识别的线程。 mFrameProcessor = new FrameProcessor(mDevice, this); threadName = String8::format(\"C2-%d-FrameProc\",mCameraId); mFrameProcessor->run(threadName.string()); // 3.3 CaptureSequencer：拍照流程状态机线程，拍照的场景非常多，后面会发出状态机的运转流程。 mCaptureSequencer = new CaptureSequencer(this); threadName = String8::format(\"C2-%d-CaptureSeq\",mCameraId); mCaptureSequencer->run(threadName.string()); // 3.4 JpegProcessor：用来处理拍照 jpeg stream 线程 mJpegProcessor = new JpegProcessor(this, mCaptureSequencer); threadName = String8::format(\"C2-%d-JpegProc\",mCameraId); mJpegProcessor->run(threadName.string()); // 3.5 ZslProcessor3：这个处理零延时zsl stream使用的线程 mZslProcessor = new ZslProcessor(this, mCaptureSequencer); threadName = String8::format(\"C2-%d-ZslProc\",mCameraId); mZslProcessor->run(threadName.string()); // 3.6 mCallbackProcessor：处理callback的线程，主要包含对 callback stream 的创建函数 updateStream()以及处理 HAL 层传上来的 callback stream 的线程 mCallbackProcessor = new CallbackProcessor(this); threadName = String8::format(\"C2-%d-CallbkProc\",mCameraId); mCallbackProcessor->run(threadName.string()); return OK; } 2.3.2.1【HAL】Camera device 初始化 mDevice->initialize(module) 调用 hardware 层的camera_module_t.common 中的 open 方法，传入Camera ID 获取 Camera相关的信息 初始化 Camera 设备 frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp status_t Camera3Device::initialize(CameraModule *module) { ALOGV(\"%s: Initializing device for camera %d\", __FUNCTION__, mId); /** Open HAL device */ String8 deviceName = String8::format(\"%d\", mId); camera3_device_t *device; ATRACE_BEGIN(\"camera3->open\"); // 1. 调用 hardware 层的camera_module_t.common 中的 open 方法，传入Camera ID res = module->open(deviceName.string(), reinterpret_cast(&device)); ===============> @ frameworks/av/services/camera/libcameraservice/common/CameraModule.cpp + res = filterOpenErrorCode(mModule->common.methods->open(&mModule->common, id, device)); + =========> + @ hardware/qcom/camera/QCamera2/QCamera2Hal.cpp + struct hw_module_methods_t QCamera2Factory::mModuleMethods = { + .open = QCamera2Factory::camera_device_open, + =====> + @ hardware/qcom/camera/QCamera2/QCamera2Factory.cpp + rc = gQCamera2Factory->cameraDeviceOpen(atoi(id), hw_device); + }; + getCameraInfo(mId, &info); // 3. 初始化 Camera 设备，设置回调函数 /** Initialize device with callback functions */ ATRACE_BEGIN(\"camera3->initialize\"); res = device->ops->initialize(device, this); ATRACE_END(); ================> + @ hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp + camera3_device_ops_t QCamera3HardwareInterface::mCameraOps = { + .initialize = QCamera3HardwareInterface::initialize, + ============> + int rc = hw->initialize(callback_ops); run(String8::format(\"C3Dev-%d-Status\", mId).string()); if (res != OK) { SET_ERR_L(\"Unable to start status tracking thread: %s (%d)\", strerror(-res), res); device->common.close(&device->common); mStatusTracker.clear(); return res; } /** Register in-flight map to the status tracker */ mInFlightStatusId = mStatusTracker->addComponent(); /** Create buffer manager */ mBufferManager = new Camera3BufferManager(); bool aeLockAvailable = false; camera_metadata_ro_entry aeLockAvailableEntry; res = find_camera_metadata_ro_entry(info.static_camera_characteristics, ANDROID_CONTROL_AE_LOCK_AVAILABLE, &aeLockAvailableEntry); if (res == OK && aeLockAvailableEntry.count > 0) { aeLockAvailable = (aeLockAvailableEntry.data.u8[0] == ANDROID_CONTROL_AE_LOCK_AVAILABLE_TRUE); } /** Start up request queue thread */ mRequestThread = new RequestThread(this, mStatusTracker, device, aeLockAvailable); res = mRequestThread->run(String8::format(\"C3Dev-%d-ReqQueue\", mId).string()); if (res != OK) { SET_ERR_L(\"Unable to start request queue thread: %s (%d)\", strerror(-res), res); device->common.close(&device->common); mRequestThread.clear(); return res; } mPreparerThread = new PreparerThread(); /** Everything is good to go */ mDeviceVersion = device->common.version; mDeviceInfo = info.static_camera_characteristics; mHal3Device = device; // Determine whether we need to derive sensitivity boost values for older devices. // If post-RAW sensitivity boost range is listed, so should post-raw sensitivity control // be listed (as the default value 100) if (mDeviceVersion 0 && timestampSource.data.u8[0] == ANDROID_SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME) { mTimestampOffset = getMonoToBoottimeOffset(); } // Will the HAL be sending in early partial result metadata? if (mDeviceVersion >= CAMERA_DEVICE_API_VERSION_3_2) { camera_metadata_entry partialResultsCount = mDeviceInfo.find(ANDROID_REQUEST_PARTIAL_RESULT_COUNT); if (partialResultsCount.count > 0) { mNumPartialResults = partialResultsCount.data.i32[0]; mUsePartialResult = (mNumPartialResults > 1); } } else { camera_metadata_entry partialResultsQuirk = mDeviceInfo.find(ANDROID_QUIRKS_USE_PARTIAL_RESULT); if (partialResultsQuirk.count > 0 && partialResultsQuirk.data.u8[0] == 1) { mUsePartialResult = true; } } camera_metadata_entry configs = mDeviceInfo.find(ANDROID_SCALER_AVAILABLE_STREAM_CONFIGURATIONS); for (uint32_t i = 0; i 2.3.2.2【Hardware】打开设备 gQCamera2Factory->cameraDeviceOpen( ) hardware/qcom/camera/QCamera2/QCamera2Factory.cpp int QCamera2Factory::cameraDeviceOpen(int camera_id, struct hw_device_t **hw_device) { LOGI(\"Open camera id %d API version %d\",camera_id, mHalDescriptors[camera_id].device_version); if ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) { CAMSCOPE_INIT(CAMSCOPE_SECTION_HAL); QCamera3HardwareInterface *hw = new QCamera3HardwareInterface(mHalDescriptors[camera_id].cameraId, mCallbacks); rc = hw->openCamera(hw_device); } #ifdef QCAMERA_HAL1_SUPPORT else if (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) { QCamera2HardwareInterface *hw = new QCamera2HardwareInterface((uint32_t)camera_id); rc = hw->openCamera(hw_device); } #endif return rc; } 初始化 QCamera3HardwareInterface() hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp QCamera3HardwareInterface::QCamera3HardwareInterface(uint32_t cameraId, const camera_module_callbacks_t *callbacks) : mCameraId(cameraId), mCameraHandle(NULL), mCameraInitialized(false), mCallbacks(callbacks), ...... //省略一系列Camera 初始化默认值 { // 1. 获取HAL 层 log 等级 getLogLevel(); =========> property_get(\"persist.camera.hal.debug\", prop, \"0\"); property_get(\"persist.camera.kpi.debug\", prop, \"0\"); property_get(\"persist.camera.global.debug\", prop, \"0\"); mCommon.init(gCamCapability[cameraId]); mCameraDevice.common.tag = HARDWARE_DEVICE_TAG; mCameraDevice.common.version = CAMERA_DEVICE_API_VERSION_3_4; mCameraDevice.common.close = close_camera_device; mCameraDevice.ops = &mCameraOps; ===⇒ @ hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp mCameraDevice.priv = this; gCamCapability[cameraId]->version = CAM_HAL_V3; // TODO: hardcode for now until mctl add support for min_num_pp_bufs //TBD - To see if this hardcoding is needed. Check by printing if this is filled by mctl to 3 gCamCapability[cameraId]->min_num_pp_bufs = 3; pthread_condattr_t mCondAttr; pthread_condattr_init(&mCondAttr); pthread_condattr_setclock(&mCondAttr, CLOCK_MONOTONIC); pthread_cond_init(&mBuffersCond, &mCondAttr); pthread_cond_init(&mRequestCond, &mCondAttr); pthread_cond_init(&mHdrRequestCond, &mCondAttr); pthread_condattr_destroy(&mCondAttr); mPendingLiveRequest = 0; mCurrentRequestId = -1; pthread_mutex_init(&mMutex, NULL); for (size_t i = 0; i rdi_mode_stream_fmt; //Load and read GPU library. lib_surface_utils = NULL; LINK_get_surface_pixel_alignment = NULL; mSurfaceStridePadding = CAM_PAD_TO_32; // 打开 libadreno_utils.so lib_surface_utils = dlopen(\"libadreno_utils.so\", RTLD_NOW); if (lib_surface_utils) { *(void **)&LINK_get_surface_pixel_alignment = dlsym(lib_surface_utils, \"get_gpu_pixel_alignment\"); if (LINK_get_surface_pixel_alignment) { mSurfaceStridePadding = LINK_get_surface_pixel_alignment(); } dlclose(lib_surface_utils); } if (gCamCapability[cameraId]->is_quadracfa_sensor) { LOGI(\"Sensor support Quadra CFA mode\"); m_bQuadraCfaSensor = true; } m_bQuadraCfaRequest = false; m_bQuadraSizeConfigured = false; memset(&mStreamList, 0, sizeof(camera3_stream_configuration_t)); } 接下来，调用 hw->openCamera(hw_device); hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp int QCamera3HardwareInterface::openCamera(struct hw_device_t **hw_device) { if (mState != CLOSED) { *hw_device = NULL; return PERMISSION_DENIED; } mPerfLockMgr.acquirePerfLock(PERF_LOCK_OPEN_CAMERA); LOGI(\"[KPI Perf]: E PROFILE_OPEN_CAMERA camera id %d\",mCameraId); rc = openCamera(); if (rc == 0) { *hw_device = &mCameraDevice.common; } else { *hw_device = NULL; } LOGI(\"[KPI Perf]: X PROFILE_OPEN_CAMERA camera id %d, rc: %d\", mCameraId, rc); if (rc == NO_ERROR) { mState = OPENED; } return rc; } 接下来调用 int QCamera3HardwareInterface::openCamera() @ hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp int QCamera3HardwareInterface::openCamera() { KPI_ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL3_OPENCAMERA); if (mCameraHandle) { LOGE(\"Failure: Camera already opened\"); return ALREADY_EXISTS; } rc = QCameraFlash::getInstance().reserveFlashForCamera(mCameraId); if (rc ops->register_event_notify(mCameraHandle->camera_handle, camEvtHandle, (void *)this); mExifParams.debug_params = (mm_jpeg_debug_exif_params_t *) malloc (sizeof(mm_jpeg_debug_exif_params_t)); if (mExifParams.debug_params) { memset(mExifParams.debug_params, 0, sizeof(mm_jpeg_debug_exif_params_t)); } else { LOGE(\"Out of Memory. Allocation failed for 3A debug exif params\"); return NO_MEMORY; } mFirstConfiguration = true; //Notify display HAL that a camera session is active. //But avoid calling the same during bootup because camera service might open/close //cameras at boot time during its initialization and display service will also internally //wait for camera service to initialize first while calling this display API, resulting in a //deadlock situation. Since boot time camera open/close calls are made only to fetch //capabilities, no need of this display bw optimization. //Use \"service.bootanim.exit\" property to know boot status. property_get(\"service.bootanim.exit\", value, \"0\"); if (atoi(value) == 1) { pthread_mutex_lock(&gCamLock); if (gNumCameraSessions++ == 0) { setCameraLaunchStatus(true); } pthread_mutex_unlock(&gCamLock); } //fill the session id needed while linking dual cam pthread_mutex_lock(&gCamLock); rc = mCameraHandle->ops->get_session_id(mCameraHandle->camera_handle, &sessionId[mCameraId]); pthread_mutex_unlock(&gCamLock); if (rc allocate(sizeof(cam_dual_camera_cmd_info_t)); if(rc != OK) { rc = NO_MEMORY; LOGE(\"Dualcam: Failed to allocate Related cam sync Heap memory\"); return NO_MEMORY; } //Map memory for related cam sync buffer rc = mCameraHandle->ops->map_buf(mCameraHandle->camera_handle, CAM_MAPPING_BUF_TYPE_DUAL_CAM_CMD_BUF, m_pDualCamCmdHeap->getFd(0), sizeof(cam_dual_camera_cmd_info_t), m_pDualCamCmdHeap->getPtr(0)); if(rc (1) camera_open((uint8_t)mCameraId, &mCameraHandle) 打开Camera 成功后，hardware 层中将Camera 所有信息保存在 g_cam_ctrl.cam_obj[cam_idx] 中，同时返回对应的camera 的opt 操作函数 hardware/qcom/camera/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c int32_t camera_open(uint8_t camera_idx, mm_camera_vtbl_t **camera_vtbl) { int32_t rc = 0; mm_camera_obj_t *cam_obj = NULL; uint32_t cam_idx = camera_idx; uint32_t aux_idx = 0; uint8_t is_multi_camera = 0; #ifdef QCAMERA_REDEFINE_LOG mm_camera_debug_open(); #endif LOGD(\"E camera_idx = %d\\n\", camera_idx); if (is_dual_camera_by_idx(camera_idx)) { is_multi_camera = 1; cam_idx = mm_camera_util_get_handle_by_num(0,g_cam_ctrl.cam_index[camera_idx]); aux_idx = (get_aux_camera_handle(g_cam_ctrl.cam_index[camera_idx]) >> MM_CAMERA_HANDLE_SHIFT_MASK); LOGH(\"Dual Camera: Main ID = %d Aux ID = %d\", cam_idx, aux_idx); } pthread_mutex_lock(&g_intf_lock); /* opened already */ if(NULL != g_cam_ctrl.cam_obj[cam_idx] && g_cam_ctrl.cam_obj[cam_idx]->ref_count != 0) { pthread_mutex_unlock(&g_intf_lock); LOGE(\"Camera %d is already open\", cam_idx); return -EBUSY; } cam_obj = (mm_camera_obj_t *)malloc(sizeof(mm_camera_obj_t)); /* initialize camera obj */ memset(cam_obj, 0, sizeof(mm_camera_obj_t)); cam_obj->ctrl_fd = -1; cam_obj->ds_fd = -1; cam_obj->ref_count++; cam_obj->my_num = 0; cam_obj->my_hdl = mm_camera_util_generate_handler(cam_idx); cam_obj->vtbl.camera_handle = cam_obj->my_hdl; /* set handler */ cam_obj->vtbl.ops = &mm_camera_ops; pthread_mutex_init(&cam_obj->cam_lock, NULL); pthread_mutex_init(&cam_obj->muxer_lock, NULL); /* unlock global interface lock, if not, in dual camera use case, * current open will block operation of another opened camera obj*/ pthread_mutex_lock(&cam_obj->cam_lock); pthread_mutex_unlock(&g_intf_lock); rc = mm_camera_open(cam_obj); if (is_multi_camera) { /*Open Aux camer's*/ pthread_mutex_lock(&g_intf_lock); if(NULL != g_cam_ctrl.cam_obj[aux_idx] && g_cam_ctrl.cam_obj[aux_idx]->ref_count != 0) { pthread_mutex_unlock(&g_intf_lock); LOGE(\"Camera %d is already open\", aux_idx); rc = -EBUSY; } else { pthread_mutex_lock(&cam_obj->muxer_lock); pthread_mutex_unlock(&g_intf_lock); rc = mm_camera_muxer_camera_open(aux_idx, cam_obj); } } LOGH(\"Open succeded: handle = %d\", cam_obj->vtbl.camera_handle); g_cam_ctrl.cam_obj[cam_idx] = cam_obj; *camera_vtbl = &cam_obj->vtbl; return 0; } 此时Open 对应的 /dev/video 节点，获得对应的session_id，创建好相关的 socket ，最终所有信息，保存在 mm_camera_obj_t * cam_obj节构体中。 @ hardware/qcom/camera/QCamera2/stack/mm-camera-interface/src/mm_camera.c int32_t mm_camera_open(mm_camera_obj_t *my_obj) { char dev_name[MM_CAMERA_DEV_NAME_LEN]; int8_t n_try=MM_CAMERA_DEV_OPEN_TRIES; uint8_t sleep_msec=MM_CAMERA_DEV_OPEN_RETRY_SLEEP; int cam_idx = 0; const char *dev_name_value = NULL; LOGD(\"begin\\n\"); dev_name_value = mm_camera_util_get_dev_name_by_num(my_obj->my_num, my_obj->my_hdl); snprintf(dev_name, sizeof(dev_name), \"/dev/%s\",dev_name_value); sscanf(dev_name, \"/dev/video%d\", &cam_idx); LOGD(\"dev name = %s, cam_idx = %d\", dev_name, cam_idx); do{ n_try--; errno = 0; my_obj->ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK); l_errno = errno; LOGD(\"ctrl_fd = %d, errno == %d\", my_obj->ctrl_fd, l_errno); if((my_obj->ctrl_fd >= 0) || (errno != EIO && errno != ETIMEDOUT) || (n_try 0); mm_camera_get_session_id(my_obj, &my_obj->sessionid); LOGH(\"Camera Opened id = %d sessionid = %d\", cam_idx, my_obj->sessionid); #ifdef DAEMON_PRESENT /* open domain socket*/ n_try = MM_CAMERA_DEV_OPEN_TRIES; do { n_try--; my_obj->ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP); l_errno = errno; LOGD(\"ds_fd = %d, errno = %d\", my_obj->ds_fd, l_errno); if((my_obj->ds_fd >= 0) || (n_try 0); #else /* DAEMON_PRESENT */ cam_status_t cam_status; cam_status = mm_camera_module_open_session(my_obj->sessionid,mm_camera_module_event_handler); #endif /* DAEMON_PRESENT */ pthread_condattr_init(&cond_attr); pthread_condattr_setclock(&cond_attr, CLOCK_MONOTONIC); pthread_mutex_init(&my_obj->msg_lock, NULL); pthread_mutex_init(&my_obj->cb_lock, NULL); pthread_mutex_init(&my_obj->evt_lock, NULL); pthread_cond_init(&my_obj->evt_cond, &cond_attr); pthread_condattr_destroy(&cond_attr); LOGD(\"Launch evt Thread in Cam Open\"); snprintf(my_obj->evt_thread.threadName, THREAD_NAME_SIZE, \"CAM_Dispatch\"); mm_camera_cmd_thread_launch(&my_obj->evt_thread, mm_camera_dispatch_app_event, (void *)my_obj); /* launch event poll thread * we will add evt fd into event poll thread upon user first register for evt */ LOGD(\"Launch evt Poll Thread in Cam Open\"); snprintf(my_obj->evt_poll_thread.threadName, THREAD_NAME_SIZE, \"CAM_evntPoll\"); mm_camera_poll_thread_launch(&my_obj->evt_poll_thread, MM_CAMERA_POLL_TYPE_EVT); mm_camera_evt_sub(my_obj, TRUE); /* unlock cam_lock, we need release global intf_lock in camera_open(), * in order not block operation of other Camera in dual camera use case.*/ pthread_mutex_unlock(&my_obj->cam_lock); LOGD(\"end (rc = %d)\\n\", rc); return rc; } (2) Camera 操作节构体 cam_obj->vtbl.ops hardware/qcom/camera/QCamera2/stack/mm-camera-interface/src/mm_camera_interface.c static mm_camera_ops_t mm_camera_ops = { .query_capability = mm_camera_intf_query_capability, .register_event_notify = mm_camera_intf_register_event_notify, .close_camera = mm_camera_intf_close, .set_parms = mm_camera_intf_set_parms, .get_parms = mm_camera_intf_get_parms, .do_auto_focus = mm_camera_intf_do_auto_focus, .cancel_auto_focus = mm_camera_intf_cancel_auto_focus, .prepare_snapshot = mm_camera_intf_prepare_snapshot, .start_zsl_snapshot = mm_camera_intf_start_zsl_snapshot, .stop_zsl_snapshot = mm_camera_intf_stop_zsl_snapshot, .map_buf = mm_camera_intf_map_buf, .map_bufs = mm_camera_intf_map_bufs, .unmap_buf = mm_camera_intf_unmap_buf, .add_channel = mm_camera_intf_add_channel, .delete_channel = mm_camera_intf_del_channel, .get_bundle_info = mm_camera_intf_get_bundle_info, .add_stream = mm_camera_intf_add_stream, .link_stream = mm_camera_intf_link_stream, .delete_stream = mm_camera_intf_del_stream, .config_stream = mm_camera_intf_config_stream, .qbuf = mm_camera_intf_qbuf, .cancel_buffer = mm_camera_intf_cancel_buf, .get_queued_buf_count = mm_camera_intf_get_queued_buf_count, .map_stream_buf = mm_camera_intf_map_stream_buf, .map_stream_bufs = mm_camera_intf_map_stream_bufs, .unmap_stream_buf = mm_camera_intf_unmap_stream_buf, .set_stream_parms = mm_camera_intf_set_stream_parms, .get_stream_parms = mm_camera_intf_get_stream_parms, .start_channel = mm_camera_intf_start_channel, .stop_channel = mm_camera_intf_stop_channel, .request_super_buf = mm_camera_intf_request_super_buf, .cancel_super_buf_request = mm_camera_intf_cancel_super_buf_request, .flush_super_buf_queue = mm_camera_intf_flush_super_buf_queue, .configure_notify_mode = mm_camera_intf_configure_notify_mode, .process_advanced_capture = mm_camera_intf_process_advanced_capture, .get_session_id = mm_camera_intf_get_session_id, .set_dual_cam_cmd = mm_camera_intf_set_dual_cam_cmd, .flush = mm_camera_intf_flush, .register_stream_buf_cb = mm_camera_intf_register_stream_buf_cb, .register_frame_sync = mm_camera_intf_reg_frame_sync, .handle_frame_sync_cb = mm_camera_intf_handle_frame_sync_cb }; 2.3.2.3 【Hardware】 初始化Framewroks层的Callback 函数 QCamera3HardwareInterface::initialize( ) hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp /*=========================================================================== * FUNCTION : initialize * DESCRIPTION: Initialize frameworks callback functions * @callback_ops : callback function to frameworks *==========================================================================*/ int QCamera3HardwareInterface::initialize(const struct camera3_callback_ops *callback_ops) { ATRACE_CAMSCOPE_CALL(CAMSCOPE_HAL3_INIT); LOGI(\"E :mCameraId = %d mState = %d\", mCameraId, mState); rc = initParameters(); mCallbackOps = callback_ops; =====> 该Callback 是从 frameworks/av/services/camera/libcameraservice/CameraService.cpp 中传递下来的 if (mModule->getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_1) { mModule->setCallbacks(this); } mChannelHandle = mCameraHandle->ops->add_channel( mCameraHandle->camera_handle, NULL, NULL, this); mCameraInitialized = true; mState = INITIALIZED; LOGI(\"X\"); return 0; } 2.4 事件处理程序（） 在 EventHandler 中，根据具体的事件，调用不同的 callback 函数。 @ frameworks/base/core/java/android/hardware/Camera.java private class EventHandler extends Handler { private final Camera mCamera; public EventHandler(Camera c, Looper looper) { super(looper); mCamera = c; } @Override public void handleMessage(Message msg) { switch(msg.what) { case CAMERA_MSG_SHUTTER: if (mShutterCallback != null) { mShutterCallback.onShutter(); } return; case CAMERA_MSG_RAW_IMAGE: if (mRawImageCallback != null) { mRawImageCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_COMPRESSED_IMAGE: if (mJpegCallback != null) { mJpegCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_PREVIEW_FRAME: PreviewCallback pCb = mPreviewCallback; if (pCb != null) { if (mOneShot) { // Clear the callback variable before the callback // in case the app calls setPreviewCallback from // the callback function mPreviewCallback = null; } else if (!mWithBuffer) { // We're faking the camera preview mode to prevent // the app from being flooded with preview frames. // Set to oneshot mode again. setHasPreviewCallback(true, false); } pCb.onPreviewFrame((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_POSTVIEW_FRAME: if (mPostviewCallback != null) { mPostviewCallback.onPictureTaken((byte[])msg.obj, mCamera); } return; case CAMERA_MSG_FOCUS: AutoFocusCallback cb = null; synchronized (mAutoFocusCallbackLock) { cb = mAutoFocusCallback; } if (cb != null) { boolean success = msg.arg1 == 0 ? false : true; cb.onAutoFocus(success, mCamera); } return; case CAMERA_MSG_ZOOM: if (mZoomListener != null) { mZoomListener.onZoomChange(msg.arg1, msg.arg2 != 0, mCamera); } return; case CAMERA_MSG_PREVIEW_METADATA: if (mFaceListener != null) { mFaceListener.onFaceDetection((Face[])msg.obj, mCamera); } return; case CAMERA_MSG_ERROR : Log.e(TAG, \"Error \" + msg.arg1); if (mErrorCallback != null) { mErrorCallback.onError(msg.arg1, mCamera); } return; case CAMERA_MSG_FOCUS_MOVE: if (mAutoFocusMoveCallback != null) { mAutoFocusMoveCallback.onAutoFocusMoving(msg.arg1 == 0 ? false : true, mCamera); } return; /* ### QC ADD-ONS: START */ case CAMERA_MSG_STATS_DATA: int statsdata[] = new int[257]; for(int i =0; i 至此，整个open Camera 流程就完了。 copyright by duguosheng all right reserved，powered by Gitbook该文件修订时间： 2022-08-16 14:16:14 "}}